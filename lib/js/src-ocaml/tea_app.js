// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Web = require("./web.js");
var List = require("bs-platform/lib/js/list.js");
var Vdom = require("./vdom.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Tea_cmd = require("./tea_cmd.js");
var Tea_sub = require("./tea_sub.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function programStateWrapper(initModel, pump, shutdown) {
  var model = {
    contents: initModel
  };
  var callbacks = {
    contents: {
      enqueue: (function (_msg) {
          console.log("INVALID enqueue CALL!");
          
        }),
      on: (function (param) {
          
        })
    }
  };
  var pumperInterface = Curry._1(pump, callbacks);
  var pending = {
    contents: undefined
  };
  var handler = function (msg) {
    var msgs = pending.contents;
    if (msgs !== undefined) {
      pending.contents = /* :: */[
        msg,
        msgs
      ];
      return ;
    }
    pending.contents = /* [] */0;
    var newModel = Curry._2(pumperInterface.handleMsg, model.contents, msg);
    model.contents = newModel;
    var msgs$1 = pending.contents;
    if (msgs$1 !== undefined) {
      if (msgs$1) {
        pending.contents = undefined;
        return List.iter(handler, List.rev(msgs$1));
      } else {
        pending.contents = undefined;
        return ;
      }
    }
    throw [
          Caml_builtin_exceptions.failure,
          "INVALID message queue state, should never be None during message processing!"
        ];
  };
  var render_events = {
    contents: /* [] */0
  };
  var finalizedCBs_enqueue = handler;
  var finalizedCBs_on = function (msg) {
    if (typeof msg === "number") {
      return List.iter(handler, render_events.contents);
    }
    if (!msg.tag) {
      render_events.contents = List.append(render_events.contents, /* :: */[
            msg[0],
            /* [] */0
          ]);
      return ;
    }
    var msg$1 = msg[0];
    render_events.contents = List.filter((function (mg) {
              return msg$1 !== mg;
            }))(render_events.contents);
    
  };
  var finalizedCBs = {
    enqueue: finalizedCBs_enqueue,
    on: finalizedCBs_on
  };
  callbacks.contents = finalizedCBs;
  var pi_requestShutdown = function (param) {
    callbacks.contents = {
      enqueue: (function (_msg) {
          console.log("INVALID message enqueued when shut down");
          
        }),
      on: (function (param) {
          
        })
    };
    var cmd = Curry._1(shutdown, model.contents);
    Curry._1(pumperInterface.shutdown, cmd);
    
  };
  var render_string = function (param) {
    return Curry._1(pumperInterface.render_string, model.contents);
  };
  Curry._1(pumperInterface.startup, undefined);
  return {
          pushMsg: handler,
          shutdown: pi_requestShutdown,
          getHtmlString: render_string
        };
}

function programLoop(update, view, subscriptions, initModel, initCmd, parentNode) {
  if (parentNode === undefined) {
    return (function (callbacks) {
        var oldSub = {
          contents: /* NoSub */0
        };
        var handleSubscriptionChange = function (model) {
          var newSub = Curry._1(subscriptions, model);
          oldSub.contents = Tea_sub.run(callbacks, callbacks, oldSub.contents, newSub);
          
        };
        return {
                startup: (function (param) {
                    Tea_cmd.run(callbacks, initCmd);
                    handleSubscriptionChange(initModel);
                    
                  }),
                render_string: (function (model) {
                    return Vdom.renderToHtmlString(Curry._1(view, model));
                  }),
                handleMsg: (function (model, msg) {
                    var match = Curry._2(update, model, msg);
                    var newModel = match[0];
                    Tea_cmd.run(callbacks, match[1]);
                    handleSubscriptionChange(newModel);
                    return newModel;
                  }),
                shutdown: (function (cmd) {
                    Tea_cmd.run(callbacks, cmd);
                    oldSub.contents = Tea_sub.run(callbacks, callbacks, oldSub.contents, /* NoSub */0);
                    
                  })
              };
      });
  }
  var parentNode$1 = Caml_option.valFromOption(parentNode);
  return (function (callbacks) {
      var priorRenderedVdom = {
        contents: /* [] */0
      };
      var latestModel = {
        contents: initModel
      };
      var nextFrameID = {
        contents: undefined
      };
      var doRender = function (_delta) {
        var _id = nextFrameID.contents;
        if (_id === undefined) {
          return ;
        }
        var newVdom_000 = Curry._1(view, latestModel.contents);
        var newVdom = /* :: */[
          newVdom_000,
          /* [] */0
        ];
        var justRenderedVdom = Vdom.patchVNodesIntoElement(callbacks, parentNode$1, priorRenderedVdom.contents, newVdom);
        priorRenderedVdom.contents = justRenderedVdom;
        Curry._1(callbacks.contents.on, /* Render */0);
        nextFrameID.contents = undefined;
        
      };
      var scheduleRender = function (param) {
        var match = nextFrameID.contents;
        if (match !== undefined) {
          return ;
        }
        var id = window.requestAnimationFrame(doRender);
        nextFrameID.contents = id;
        
      };
      var clearPnode = function (param) {
        while(parentNode$1.childNodes.length > 0) {
          var firstChild = parentNode$1.firstChild;
          if (firstChild !== null) {
            parentNode$1.removeChild(firstChild);
          }
          
        };
        
      };
      var oldSub = {
        contents: /* NoSub */0
      };
      var handleSubscriptionChange = function (model) {
        var newSub = Curry._1(subscriptions, model);
        oldSub.contents = Tea_sub.run(callbacks, callbacks, oldSub.contents, newSub);
        
      };
      var handlerStartup = function (param) {
        clearPnode(undefined);
        Tea_cmd.run(callbacks, initCmd);
        handleSubscriptionChange(latestModel.contents);
        nextFrameID.contents = -1;
        doRender(16);
        
      };
      var render_string = function (model) {
        return Vdom.renderToHtmlString(Curry._1(view, model));
      };
      var handler = function (model, msg) {
        var match = Curry._2(update, model, msg);
        var newModel = match[0];
        latestModel.contents = newModel;
        Tea_cmd.run(callbacks, match[1]);
        scheduleRender(undefined);
        handleSubscriptionChange(newModel);
        return newModel;
      };
      var handlerShutdown = function (cmd) {
        nextFrameID.contents = undefined;
        Tea_cmd.run(callbacks, cmd);
        oldSub.contents = Tea_sub.run(callbacks, callbacks, oldSub.contents, /* NoSub */0);
        priorRenderedVdom.contents = /* [] */0;
        clearPnode(undefined);
        
      };
      return {
              startup: handlerStartup,
              render_string: render_string,
              handleMsg: handler,
              shutdown: handlerShutdown
            };
    });
}

function program(param, pnode, flags) {
  Web.polyfills(undefined);
  var match = Curry._1(param.init, flags);
  var initModel = match[0];
  var opnode = (pnode == null) ? undefined : Caml_option.some(pnode);
  var pumpInterface = programLoop(param.update, param.view, param.subscriptions, initModel, match[1], opnode);
  return programStateWrapper(initModel, pumpInterface, param.shutdown);
}

function standardProgram(param, pnode, args) {
  return program({
              init: param.init,
              update: param.update,
              view: param.view,
              subscriptions: param.subscriptions,
              shutdown: (function (_model) {
                  return /* NoCmd */0;
                })
            }, pnode, args);
}

function beginnerProgram(param, pnode, param$1) {
  var update = param.update;
  var model = param.model;
  return standardProgram({
              init: (function (param) {
                  return /* tuple */[
                          model,
                          /* NoCmd */0
                        ];
                }),
              update: (function (model, msg) {
                  return /* tuple */[
                          Curry._2(update, model, msg),
                          /* NoCmd */0
                        ];
                }),
              view: param.view,
              subscriptions: (function (_model) {
                  return /* NoSub */0;
                })
            }, pnode, undefined);
}

var map = Vdom.map;

exports.programStateWrapper = programStateWrapper;
exports.programLoop = programLoop;
exports.program = program;
exports.standardProgram = standardProgram;
exports.beginnerProgram = beginnerProgram;
exports.map = map;
/* No side effect */
