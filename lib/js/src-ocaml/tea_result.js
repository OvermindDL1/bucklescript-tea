// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function result_to_option(a) {
  if (a.tag) {
    return ;
  } else {
    return Caml_option.some(a[0]);
  }
}

function option_of_result(a) {
  if (a.tag) {
    return ;
  } else {
    return Caml_option.some(a[0]);
  }
}

function ok(a) {
  if (a.tag) {
    return ;
  } else {
    return Caml_option.some(a[0]);
  }
}

function error(e) {
  if (e.tag) {
    return Caml_option.some(e[0]);
  }
  
}

function last_of(_param) {
  while(true) {
    var param = _param;
    if (param) {
      var tl = param[1];
      var last = param[0];
      if (!tl) {
        return last;
      }
      if (last.tag) {
        return last;
      }
      _param = tl;
      continue ;
    }
    throw [
          Caml_builtin_exceptions.failure,
          "`Tea.Result.do` must never be passed the empty list"
        ];
  };
}

function accumulate(param) {
  if (!param) {
    return /* Ok */Block.__(0, [/* [] */0]);
  }
  var tl = param[1];
  var last = param[0];
  if (!tl) {
    if (last.tag) {
      return last;
    } else {
      return /* Ok */Block.__(0, [/* :: */[
                  last[0],
                  /* [] */0
                ]]);
    }
  }
  if (last.tag) {
    return last;
  }
  var e = accumulate(tl);
  if (e.tag) {
    return e;
  } else {
    return /* Ok */Block.__(0, [/* :: */[
                last[0],
                e[0]
              ]]);
  }
}

function first(fst, e) {
  if (e.tag) {
    return e;
  } else {
    return fst;
  }
}

function error_of_any(_param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var hd = param[0];
    if (hd.tag) {
      return Caml_option.some(hd[0]);
    }
    _param = param[1];
    continue ;
  };
}

function error_of_first(fst, e) {
  if (e.tag) {
    return Caml_option.some(e[0]);
  } else {
    return error(fst);
  }
}

exports.result_to_option = result_to_option;
exports.option_of_result = option_of_result;
exports.ok = ok;
exports.error = error;
exports.last_of = last_of;
exports.accumulate = accumulate;
exports.first = first;
exports.error_of_any = error_of_any;
exports.error_of_first = error_of_first;
/* No side effect */
