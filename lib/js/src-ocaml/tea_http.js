// Generated by BUCKLESCRIPT VERSION 4.0.7, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Tea_json = require("./tea_json.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Web_xmlhttprequest = require("./web_xmlhttprequest.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function string_of_error(param) {
  if (typeof param === "number") {
    switch (param) {
      case 0 : 
          return "Timeout";
      case 1 : 
          return "Unknown network error";
      case 2 : 
          return "Request aborted";
      
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return "Bad Url: " + param[0];
      case 1 : 
          return "Bad Status: " + param[0][/* url */0];
      case 2 : 
          return "Bad Payload: " + param[1][/* url */0];
      
    }
  }
}

var emptyRequestEvents = /* record */[
  /* onreadystatechange */undefined,
  /* onprogress */undefined
];

function expectStringResponse(func) {
  return /* Expect */[
          /* TextResponseType */5,
          (function (param) {
              var body = param[/* body */3];
              if (typeof body === "number" || body.tag !== 5) {
                return /* Error */Block.__(1, ["Non-text response returned"]);
              } else {
                return Curry._1(func, body[0]);
              }
            })
        ];
}

var expectString = expectStringResponse((function (resString) {
        return /* Ok */Block.__(0, [resString]);
      }));

function request(rawRequest) {
  return /* Request */[
          rawRequest,
          undefined
        ];
}

function getString(url) {
  return /* Request */[
          /* record */[
            /* method' */"GET",
            /* headers : [] */0,
            /* url */url,
            /* body : EmptyBody */0,
            /* expect */expectString,
            /* timeout */undefined,
            /* withCredentials */false
          ],
          undefined
        ];
}

function send(resultToMessage, param) {
  var maybeEvents = param[1];
  var request = param[0];
  var height = function (param) {
    if (param) {
      return param[4];
    } else {
      return 0;
    }
  };
  var create = function (l, x, d, r) {
    var hl = height(l);
    var hr = height(r);
    return /* Node */[
            l,
            x,
            d,
            r,
            hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          ];
  };
  var singleton = function (x, d) {
    return /* Node */[
            /* Empty */0,
            x,
            d,
            /* Empty */0,
            1
          ];
  };
  var bal = function (l, x, d, r) {
    var hl = l ? l[4] : 0;
    var hr = r ? r[4] : 0;
    if (hl > (hr + 2 | 0)) {
      if (l) {
        var lr = l[3];
        var ld = l[2];
        var lv = l[1];
        var ll = l[0];
        if (height(ll) >= height(lr)) {
          return create(ll, lv, ld, create(lr, x, d, r));
        } else if (lr) {
          return create(create(ll, lv, ld, lr[0]), lr[1], lr[2], create(lr[3], x, d, r));
        } else {
          throw [
                Caml_builtin_exceptions.invalid_argument,
                "Map.bal"
              ];
        }
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            ];
      }
    } else if (hr > (hl + 2 | 0)) {
      if (r) {
        var rr = r[3];
        var rd = r[2];
        var rv = r[1];
        var rl = r[0];
        if (height(rr) >= height(rl)) {
          return create(create(l, x, d, rl), rv, rd, rr);
        } else if (rl) {
          return create(create(l, x, d, rl[0]), rl[1], rl[2], create(rl[3], rv, rd, rr));
        } else {
          throw [
                Caml_builtin_exceptions.invalid_argument,
                "Map.bal"
              ];
        }
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            ];
      }
    } else {
      return /* Node */[
              l,
              x,
              d,
              r,
              hl >= hr ? hl + 1 | 0 : hr + 1 | 0
            ];
    }
  };
  var add = function (x, data, param) {
    if (param) {
      var r = param[3];
      var d = param[2];
      var v = param[1];
      var l = param[0];
      var c = Caml_primitive.caml_string_compare(x, v);
      if (c === 0) {
        return /* Node */[
                l,
                x,
                data,
                r,
                param[4]
              ];
      } else if (c < 0) {
        return bal(add(x, data, l), v, d, r);
      } else {
        return bal(l, v, d, add(x, data, r));
      }
    } else {
      return /* Node */[
              /* Empty */0,
              x,
              data,
              /* Empty */0,
              1
            ];
    }
  };
  var min_binding = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var l = param[0];
        if (l) {
          _param = l;
          continue ;
        } else {
          return /* tuple */[
                  param[1],
                  param[2]
                ];
        }
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    };
  };
  var remove_min_binding = function (param) {
    if (param) {
      var l = param[0];
      if (l) {
        return bal(remove_min_binding(l), param[1], param[2], param[3]);
      } else {
        return param[3];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.remove_min_elt"
          ];
    }
  };
  var remove = function (x, param) {
    if (param) {
      var r = param[3];
      var d = param[2];
      var v = param[1];
      var l = param[0];
      var c = Caml_primitive.caml_string_compare(x, v);
      if (c === 0) {
        var t1 = l;
        var t2 = r;
        if (t1) {
          if (t2) {
            var match = min_binding(t2);
            return bal(t1, match[0], match[1], remove_min_binding(t2));
          } else {
            return t1;
          }
        } else {
          return t2;
        }
      } else if (c < 0) {
        return bal(remove(x, l), v, d, r);
      } else {
        return bal(l, v, d, remove(x, r));
      }
    } else {
      return /* Empty */0;
    }
  };
  var iter = function (f, _param) {
    while(true) {
      var param = _param;
      if (param) {
        iter(f, param[0]);
        Curry._2(f, param[1], param[2]);
        _param = param[3];
        continue ;
      } else {
        return /* () */0;
      }
    };
  };
  var map = function (f, param) {
    if (param) {
      var l$prime = map(f, param[0]);
      var d$prime = Curry._1(f, param[2]);
      var r$prime = map(f, param[3]);
      return /* Node */[
              l$prime,
              param[1],
              d$prime,
              r$prime,
              param[4]
            ];
    } else {
      return /* Empty */0;
    }
  };
  var mapi = function (f, param) {
    if (param) {
      var v = param[1];
      var l$prime = mapi(f, param[0]);
      var d$prime = Curry._2(f, v, param[2]);
      var r$prime = mapi(f, param[3]);
      return /* Node */[
              l$prime,
              v,
              d$prime,
              r$prime,
              param[4]
            ];
    } else {
      return /* Empty */0;
    }
  };
  var fold = function (f, _m, _accu) {
    while(true) {
      var accu = _accu;
      var m = _m;
      if (m) {
        _accu = Curry._3(f, m[1], m[2], fold(f, m[0], accu));
        _m = m[3];
        continue ;
      } else {
        return accu;
      }
    };
  };
  var for_all = function (p, _param) {
    while(true) {
      var param = _param;
      if (param) {
        if (Curry._2(p, param[1], param[2]) && for_all(p, param[0])) {
          _param = param[3];
          continue ;
        } else {
          return false;
        }
      } else {
        return true;
      }
    };
  };
  var exists = function (p, _param) {
    while(true) {
      var param = _param;
      if (param) {
        if (Curry._2(p, param[1], param[2]) || exists(p, param[0])) {
          return true;
        } else {
          _param = param[3];
          continue ;
        }
      } else {
        return false;
      }
    };
  };
  var add_min_binding = function (k, v, param) {
    if (param) {
      return bal(add_min_binding(k, v, param[0]), param[1], param[2], param[3]);
    } else {
      return singleton(k, v);
    }
  };
  var add_max_binding = function (k, v, param) {
    if (param) {
      return bal(param[0], param[1], param[2], add_max_binding(k, v, param[3]));
    } else {
      return singleton(k, v);
    }
  };
  var join = function (l, v, d, r) {
    if (l) {
      if (r) {
        var rh = r[4];
        var lh = l[4];
        if (lh > (rh + 2 | 0)) {
          return bal(l[0], l[1], l[2], join(l[3], v, d, r));
        } else if (rh > (lh + 2 | 0)) {
          return bal(join(l, v, d, r[0]), r[1], r[2], r[3]);
        } else {
          return create(l, v, d, r);
        }
      } else {
        return add_max_binding(v, d, l);
      }
    } else {
      return add_min_binding(v, d, r);
    }
  };
  var concat = function (t1, t2) {
    if (t1) {
      if (t2) {
        var match = min_binding(t2);
        return join(t1, match[0], match[1], remove_min_binding(t2));
      } else {
        return t1;
      }
    } else {
      return t2;
    }
  };
  var concat_or_join = function (t1, v, d, t2) {
    if (d !== undefined) {
      return join(t1, v, Js_primitive.valFromOption(d), t2);
    } else {
      return concat(t1, t2);
    }
  };
  var split = function (x, param) {
    if (param) {
      var r = param[3];
      var d = param[2];
      var v = param[1];
      var l = param[0];
      var c = Caml_primitive.caml_string_compare(x, v);
      if (c === 0) {
        return /* tuple */[
                l,
                Js_primitive.some(d),
                r
              ];
      } else if (c < 0) {
        var match = split(x, l);
        return /* tuple */[
                match[0],
                match[1],
                join(match[2], v, d, r)
              ];
      } else {
        var match$1 = split(x, r);
        return /* tuple */[
                join(l, v, d, match$1[0]),
                match$1[1],
                match$1[2]
              ];
      }
    } else {
      return /* tuple */[
              /* Empty */0,
              undefined,
              /* Empty */0
            ];
    }
  };
  var merge = function (f, s1, s2) {
    var exit = 0;
    if (s1) {
      var v1 = s1[1];
      if (s1[4] >= height(s2)) {
        var match = split(v1, s2);
        return concat_or_join(merge(f, s1[0], match[0]), v1, Curry._3(f, v1, Js_primitive.some(s1[2]), match[1]), merge(f, s1[3], match[2]));
      } else {
        exit = 1;
      }
    } else if (s2) {
      exit = 1;
    } else {
      return /* Empty */0;
    }
    if (exit === 1) {
      if (s2) {
        var v2 = s2[1];
        var match$1 = split(v2, s1);
        return concat_or_join(merge(f, match$1[0], s2[0]), v2, Curry._3(f, v2, match$1[1], Js_primitive.some(s2[2])), merge(f, match$1[2], s2[3]));
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "map.ml",
                270,
                10
              ]
            ];
      }
    }
    
  };
  var filter = function (p, param) {
    if (param) {
      var d = param[2];
      var v = param[1];
      var l$prime = filter(p, param[0]);
      var pvd = Curry._2(p, v, d);
      var r$prime = filter(p, param[3]);
      if (pvd) {
        return join(l$prime, v, d, r$prime);
      } else {
        return concat(l$prime, r$prime);
      }
    } else {
      return /* Empty */0;
    }
  };
  var partition = function (p, param) {
    if (param) {
      var d = param[2];
      var v = param[1];
      var match = partition(p, param[0]);
      var lf = match[1];
      var lt = match[0];
      var pvd = Curry._2(p, v, d);
      var match$1 = partition(p, param[3]);
      var rf = match$1[1];
      var rt = match$1[0];
      if (pvd) {
        return /* tuple */[
                join(lt, v, d, rt),
                concat(lf, rf)
              ];
      } else {
        return /* tuple */[
                concat(lt, rt),
                join(lf, v, d, rf)
              ];
      }
    } else {
      return /* tuple */[
              /* Empty */0,
              /* Empty */0
            ];
    }
  };
  var cardinal = function (param) {
    if (param) {
      return (cardinal(param[0]) + 1 | 0) + cardinal(param[3]) | 0;
    } else {
      return 0;
    }
  };
  var bindings_aux = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (param) {
        _param = param[0];
        _accu = /* :: */[
          /* tuple */[
            param[1],
            param[2]
          ],
          bindings_aux(accu, param[3])
        ];
        continue ;
      } else {
        return accu;
      }
    };
  };
  var expect = request[/* expect */4];
  var responseToResult = expect[1];
  var typ = expect[0];
  var withCredentials = request[/* withCredentials */6];
  var timeout = request[/* timeout */5];
  var body = request[/* body */3];
  var url = request[/* url */2];
  var headers = request[/* headers */1];
  var method$prime = request[/* method' */0];
  return /* EnqueueCall */Block.__(2, [(function (callbacks) {
                var enqRes = function (result, _ev) {
                  return Curry._1(callbacks[0][/* enqueue */0], Curry._1(resultToMessage, result));
                };
                var xhr = new XMLHttpRequest();
                if (maybeEvents !== undefined) {
                  var match = maybeEvents;
                  var mayCB = function (thenDo, param) {
                    if (param !== undefined) {
                      return Curry._1(thenDo, Curry._1(param, callbacks));
                    } else {
                      return /* () */0;
                    }
                  };
                  mayCB((function (param) {
                          xhr.onreadystatechange = param;
                          return /* () */0;
                        }), match[/* onreadystatechange */0]);
                  mayCB((function (param) {
                          xhr.onprogress = param;
                          return /* () */0;
                        }), match[/* onprogress */1]);
                }
                var partial_arg = /* Error */Block.__(1, [/* NetworkError */1]);
                var cb = function (param) {
                  return enqRes(partial_arg, param);
                };
                xhr.onerror = cb;
                var partial_arg$1 = /* Error */Block.__(1, [/* Timeout */0]);
                var cb$1 = function (param) {
                  return enqRes(partial_arg$1, param);
                };
                xhr.ontimeout = cb$1;
                var partial_arg$2 = /* Error */Block.__(1, [/* Aborted */2]);
                var cb$2 = function (param) {
                  return enqRes(partial_arg$2, param);
                };
                xhr.onabort = cb$2;
                var cb$3 = function (_ev) {
                  var match = Web_xmlhttprequest.getAllResponseHeadersAsDict(xhr);
                  var headers;
                  headers = match.tag ? /* Empty */0 : match[0];
                  var response_000 = /* url */xhr.responseURL;
                  var response_001 = /* status : record */[
                    /* code */xhr.status,
                    /* message */xhr.statusText
                  ];
                  var response_003 = /* body */Web_xmlhttprequest.get_response(xhr);
                  var response = /* record */[
                    response_000,
                    response_001,
                    /* headers */headers,
                    response_003
                  ];
                  if (response_001[/* code */0] < 200 || 300 <= response_001[/* code */0]) {
                    var partial_arg = /* Error */Block.__(1, [/* BadStatus */Block.__(1, [response])]);
                    return (function (param) {
                                return enqRes(partial_arg, param);
                              })(/* () */0);
                  } else {
                    var match$1 = Curry._1(responseToResult, response);
                    if (match$1.tag) {
                      var partial_arg$1 = /* Error */Block.__(1, [/* BadPayload */Block.__(2, [
                              match$1[0],
                              response
                            ])]);
                      return (function (param) {
                                  return enqRes(partial_arg$1, param);
                                })(/* () */0);
                    } else {
                      var partial_arg$2 = /* Ok */Block.__(0, [match$1[0]]);
                      return (function (param) {
                                  return enqRes(partial_arg$2, param);
                                })(/* () */0);
                    }
                  }
                };
                xhr.onload = cb$3;
                try {
                  Web_xmlhttprequest.open_(method$prime, url, undefined, undefined, undefined, xhr);
                }
                catch (exn){
                  var partial_arg$3 = /* Error */Block.__(1, [/* BadUrl */Block.__(0, [url])]);
                  ((function (param) {
                          return enqRes(partial_arg$3, param);
                        })(/* () */0));
                }
                var setHeader = function (param) {
                  return Web_xmlhttprequest.setRequestHeader(param[0], param[1], xhr);
                };
                List.iter(setHeader, headers);
                Web_xmlhttprequest.set_responseType(typ, xhr);
                if (timeout !== undefined) {
                  xhr.timeout = timeout;
                }
                xhr.withCredentials = withCredentials;
                Web_xmlhttprequest.send(body, xhr);
                return /* () */0;
              })]);
}

function encodeUri(str) {
  return encodeURIComponent(str);
}

function decodeUri(str) {
  try {
    return decodeURIComponent(str);
  }
  catch (exn){
    return undefined;
  }
}

function track(toMessage, param) {
  var events = param[1];
  var onprogress = (function (callbacks, ev) {
      var match = Tea_json.Decoder[/* decodeValue */30](Tea_json.Decoder[/* field */11]("lengthComputable", Tea_json.Decoder[/* bool */5]), ev);
      var lengthComputable;
      lengthComputable = match.tag ? false : match[0];
      if (lengthComputable) {
        var decoder = Tea_json.Decoder[/* map2 */17]((function (bytes, bytesExpected) {
                return /* record */[
                        /* bytes */bytes,
                        /* bytesExpected */bytesExpected
                      ];
              }), Tea_json.Decoder[/* field */11]("loaded", Tea_json.Decoder[/* int */3]), Tea_json.Decoder[/* field */11]("total", Tea_json.Decoder[/* int */3]));
        var match$1 = Tea_json.Decoder[/* decodeValue */30](decoder, ev);
        if (match$1.tag) {
          return /* () */0;
        } else {
          return Curry._1(callbacks[0][/* enqueue */0], Curry._1(toMessage, match$1[0]));
        }
      } else {
        return 0;
      }
    });
  var events$1 = events !== undefined ? events : emptyRequestEvents;
  return /* Request */[
          param[0],
          /* record */[
            /* onreadystatechange */events$1[/* onreadystatechange */0],
            /* onprogress */onprogress
          ]
        ];
}

var Progress_000 = /* emptyProgress : record */[
  /* bytes */0,
  /* bytesExpected */0
];

var Progress = /* module */[
  Progress_000,
  /* track */track
];

exports.string_of_error = string_of_error;
exports.emptyRequestEvents = emptyRequestEvents;
exports.expectStringResponse = expectStringResponse;
exports.expectString = expectString;
exports.request = request;
exports.getString = getString;
exports.send = send;
exports.encodeUri = encodeUri;
exports.decodeUri = decodeUri;
exports.Progress = Progress;
/* expectString Not a pure module */
