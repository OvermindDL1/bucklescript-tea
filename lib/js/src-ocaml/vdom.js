// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Web_node = require("./web_node.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Web_document = require("./web_document.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var noNode = /* CommentNode */Block.__(0, [""]);

function comment(s) {
  return /* CommentNode */Block.__(0, [s]);
}

function text(s) {
  return /* Text */Block.__(1, [s]);
}

function fullnode(namespace, tagName, key, unique, props, vdoms) {
  return /* Node */Block.__(2, [
            namespace,
            tagName,
            key,
            unique,
            props,
            vdoms
          ]);
}

function node(namespaceOpt, tagName, keyOpt, uniqueOpt, props, vdoms) {
  var namespace = namespaceOpt !== undefined ? namespaceOpt : "";
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return fullnode(namespace, tagName, key, unique, props, vdoms);
}

function lazyGen(key, fn) {
  return /* LazyGen */Block.__(3, [
            key,
            fn,
            {
              contents: noNode
            }
          ]);
}

function prop(key, value) {
  return /* RawProp */Block.__(0, [
            key,
            value
          ]);
}

function onCB(name, key, cb) {
  return /* Event */Block.__(3, [
            name,
            /* EventHandlerCallback */Block.__(0, [
                key,
                cb
              ]),
            {
              contents: undefined
            }
          ]);
}

function onMsg(name, msg) {
  return /* Event */Block.__(3, [
            name,
            /* EventHandlerMsg */Block.__(1, [msg]),
            {
              contents: undefined
            }
          ]);
}

function attribute(namespace, key, value) {
  return /* Attribute */Block.__(1, [
            namespace,
            key,
            value
          ]);
}

function data(key, value) {
  return /* Data */Block.__(2, [
            key,
            value
          ]);
}

function style(key, value) {
  return /* Style */Block.__(4, [/* :: */[
              /* tuple */[
                key,
                value
              ],
              /* [] */0
            ]]);
}

function styles(s) {
  return /* Style */Block.__(4, [s]);
}

function renderToHtmlString(_s) {
  while(true) {
    var s = _s;
    switch (s.tag | 0) {
      case /* CommentNode */0 :
          return "<!-- " + (s[0] + " -->");
      case /* Text */1 :
          return s[0];
      case /* Node */2 :
          var tagName = s[1];
          var namespace = s[0];
          return $$String.concat("", /* :: */[
                      "<",
                      /* :: */[
                        namespace,
                        /* :: */[
                          namespace === "" ? "" : ":",
                          /* :: */[
                            tagName,
                            /* :: */[
                              $$String.concat("", List.map((function (p) {
                                          if (typeof p === "number") {
                                            return "";
                                          }
                                          switch (p.tag | 0) {
                                            case /* RawProp */0 :
                                                return $$String.concat("", /* :: */[
                                                            " ",
                                                            /* :: */[
                                                              p[0],
                                                              /* :: */[
                                                                "=\"",
                                                                /* :: */[
                                                                  p[1],
                                                                  /* :: */[
                                                                    "\"",
                                                                    /* [] */0
                                                                  ]
                                                                ]
                                                              ]
                                                            ]
                                                          ]);
                                            case /* Attribute */1 :
                                                return $$String.concat("", /* :: */[
                                                            " ",
                                                            /* :: */[
                                                              p[1],
                                                              /* :: */[
                                                                "=\"",
                                                                /* :: */[
                                                                  p[2],
                                                                  /* :: */[
                                                                    "\"",
                                                                    /* [] */0
                                                                  ]
                                                                ]
                                                              ]
                                                            ]
                                                          ]);
                                            case /* Data */2 :
                                                return $$String.concat("", /* :: */[
                                                            " data-",
                                                            /* :: */[
                                                              p[0],
                                                              /* :: */[
                                                                "=\"",
                                                                /* :: */[
                                                                  p[1],
                                                                  /* :: */[
                                                                    "\"",
                                                                    /* [] */0
                                                                  ]
                                                                ]
                                                              ]
                                                            ]
                                                          ]);
                                            case /* Event */3 :
                                                return "";
                                            case /* Style */4 :
                                                return $$String.concat("", /* :: */[
                                                            " style=\"",
                                                            /* :: */[
                                                              $$String.concat(";", List.map((function (param) {
                                                                          return $$String.concat("", /* :: */[
                                                                                      param[0],
                                                                                      /* :: */[
                                                                                        ":",
                                                                                        /* :: */[
                                                                                          param[1],
                                                                                          /* :: */[
                                                                                            ";",
                                                                                            /* [] */0
                                                                                          ]
                                                                                        ]
                                                                                      ]
                                                                                    ]);
                                                                        }), p[0])),
                                                              /* :: */[
                                                                "\"",
                                                                /* [] */0
                                                              ]
                                                            ]
                                                          ]);
                                            
                                          }
                                        }), s[4])),
                              /* :: */[
                                ">",
                                /* :: */[
                                  $$String.concat("", List.map(renderToHtmlString, s[5])),
                                  /* :: */[
                                    "</",
                                    /* :: */[
                                      tagName,
                                      /* :: */[
                                        ">",
                                        /* [] */0
                                      ]
                                    ]
                                  ]
                                ]
                              ]
                            ]
                          ]
                        ]
                      ]
                    ]);
      case /* LazyGen */3 :
          _s = Curry._1(s[1], undefined);
          continue ;
      case /* Tagger */4 :
          _s = s[1];
          continue ;
      
    }
  };
}

function emptyEventHandler(_ev) {
  
}

function emptyEventCB(_ev) {
  
}

function eventHandler(callbacks, cb) {
  return (function (ev) {
      var msg = Curry._1(cb.contents, ev);
      if (msg !== undefined) {
        return Curry._1(callbacks.contents.enqueue, Caml_option.valFromOption(msg));
      }
      
    });
}

function eventHandler_GetCB(msg) {
  if (!msg.tag) {
    return msg[1];
  }
  var msg$1 = msg[0];
  return (function (_ev) {
      return Caml_option.some(msg$1);
    });
}

function compareEventHandlerTypes(left, msg) {
  if (msg.tag) {
    if (left.tag && Caml_obj.caml_equal(msg[0], left[0])) {
      return true;
    } else {
      return false;
    }
  } else if (left.tag) {
    return false;
  } else {
    return msg[0] === left[0];
  }
}

function eventHandler_Register(callbacks, elem, name, handlerType) {
  var cb = {
    contents: eventHandler_GetCB(handlerType)
  };
  var handler = eventHandler(callbacks, cb);
  Web_node.addEventListener(elem, name, handler, false);
  return {
          handler: handler,
          cb: cb
        };
}

function eventHandler_Unregister(elem, name, cache) {
  if (cache !== undefined) {
    Web_node.removeEventListener(elem, name, cache.handler, false);
    return ;
  }
  
}

function eventHandler_Mutate(callbacks, elem, oldName, newName, oldHandlerType, newHandlerType, oldCache, newCache) {
  var oldcache = oldCache.contents;
  if (oldcache === undefined) {
    newCache.contents = eventHandler_Register(callbacks, elem, newName, newHandlerType);
    return ;
  }
  if (oldName === newName) {
    newCache.contents = oldCache.contents;
    if (compareEventHandlerTypes(oldHandlerType, newHandlerType)) {
      return ;
    }
    var cb = eventHandler_GetCB(newHandlerType);
    oldcache.cb.contents = cb;
    return ;
  }
  oldCache.contents = eventHandler_Unregister(elem, oldName, oldCache.contents);
  newCache.contents = eventHandler_Register(callbacks, elem, newName, newHandlerType);
  
}

function patchVNodesOnElems_PropertiesApply_Add(callbacks, elem, _idx, s) {
  if (typeof s === "number") {
    return ;
  }
  switch (s.tag | 0) {
    case /* RawProp */0 :
        elem[s[0]] = s[1];
        return ;
    case /* Attribute */1 :
        return Web_node.setAttributeNsOptional(elem, s[0], s[1], s[2]);
    case /* Data */2 :
        console.log(/* tuple */[
              "TODO:  Add Data Unhandled",
              s[0],
              s[1]
            ]);
        throw [
              Caml_builtin_exceptions.failure,
              "TODO:  Add Data Unhandled"
            ];
    case /* Event */3 :
        s[2].contents = eventHandler_Register(callbacks, elem, s[0], s[1]);
        return ;
    case /* Style */4 :
        return List.fold_left((function (param, param$1) {
                      return Web_node.setStyleProperty(elem, undefined, param$1[0], param$1[1]);
                    }), undefined, s[0]);
    
  }
}

function patchVNodesOnElems_PropertiesApply_Remove(_callbacks, elem, _idx, s) {
  if (typeof s === "number") {
    return ;
  }
  switch (s.tag | 0) {
    case /* RawProp */0 :
        elem[s[0]] = undefined;
        return ;
    case /* Attribute */1 :
        return Web_node.removeAttributeNsOptional(elem, s[0], s[1]);
    case /* Data */2 :
        console.log(/* tuple */[
              "TODO:  Remove Data Unhandled",
              s[0],
              s[1]
            ]);
        throw [
              Caml_builtin_exceptions.failure,
              "TODO:  Remove Data Unhandled"
            ];
    case /* Event */3 :
        var cache = s[2];
        cache.contents = eventHandler_Unregister(elem, s[0], cache.contents);
        return ;
    case /* Style */4 :
        return List.fold_left((function (param, param$1) {
                      return Web_node.setStyleProperty(elem, undefined, param$1[0], null);
                    }), undefined, s[0]);
    
  }
}

function patchVNodesOnElems_PropertiesApply_RemoveAdd(callbacks, elem, idx, oldProp, newProp) {
  patchVNodesOnElems_PropertiesApply_Remove(callbacks, elem, idx, oldProp);
  patchVNodesOnElems_PropertiesApply_Add(callbacks, elem, idx, newProp);
  
}

function patchVNodesOnElems_PropertiesApply_Mutate(_callbacks, elem, _idx, oldProp, _newProp) {
  if (typeof _newProp === "number") {
    throw [
          Caml_builtin_exceptions.failure,
          "This should never be called as all entries through NoProp are gated."
        ];
  }
  switch (_newProp.tag | 0) {
    case /* RawProp */0 :
        elem[_newProp[0]] = _newProp[1];
        return ;
    case /* Attribute */1 :
        return Web_node.setAttributeNsOptional(elem, _newProp[0], _newProp[1], _newProp[2]);
    case /* Data */2 :
        console.log(/* tuple */[
              "TODO:  Mutate Data Unhandled",
              _newProp[0],
              _newProp[1]
            ]);
        throw [
              Caml_builtin_exceptions.failure,
              "TODO:  Mutate Data Unhandled"
            ];
    case /* Event */3 :
        throw [
              Caml_builtin_exceptions.failure,
              "This will never be called because it is gated"
            ];
    case /* Style */4 :
        if (typeof oldProp === "number") {
          throw [
                Caml_builtin_exceptions.failure,
                "Passed a non-Style to a new Style as a Mutations while the old Style is not actually a style!"
              ];
        }
        if (oldProp.tag === /* Style */4) {
          return List.fold_left2((function (param, param$1, param$2) {
                        var nv = param$2[1];
                        var nk = param$2[0];
                        var ok = param$1[0];
                        if (ok === nk) {
                          if (param$1[1] === nv) {
                            return ;
                          } else {
                            return Web_node.setStyleProperty(elem, undefined, nk, nv);
                          }
                        } else {
                          Web_node.setStyleProperty(elem, undefined, ok, null);
                          return Web_node.setStyleProperty(elem, undefined, nk, nv);
                        }
                      }), undefined, oldProp[0], _newProp[0]);
        }
        throw [
              Caml_builtin_exceptions.failure,
              "Passed a non-Style to a new Style as a Mutations while the old Style is not actually a style!"
            ];
    
  }
}

function patchVNodesOnElems_PropertiesApply(callbacks, elem, _idx, _oldProperties, _newProperties) {
  while(true) {
    var newProperties = _newProperties;
    var oldProperties = _oldProperties;
    var idx = _idx;
    if (!oldProperties) {
      if (newProperties) {
        return false;
      } else {
        return true;
      }
    }
    var _oldProp = oldProperties[0];
    if (!newProperties) {
      return false;
    }
    if (typeof _oldProp === "number") {
      if (typeof newProperties[0] === "number") {
        _newProperties = newProperties[1];
        _oldProperties = oldProperties[1];
        _idx = idx + 1 | 0;
        continue ;
      }
      
    } else {
      switch (_oldProp.tag | 0) {
        case /* RawProp */0 :
            var newProp = newProperties[0];
            if (typeof newProp !== "number" && !newProp.tag) {
              if (_oldProp[0] === newProp[0] && _oldProp[1] === newProp[1]) {
                
              } else {
                patchVNodesOnElems_PropertiesApply_Mutate(callbacks, elem, idx, _oldProp, newProp);
              }
              _newProperties = newProperties[1];
              _oldProperties = oldProperties[1];
              _idx = idx + 1 | 0;
              continue ;
            }
            break;
        case /* Attribute */1 :
            var newProp$1 = newProperties[0];
            if (typeof newProp$1 !== "number" && newProp$1.tag === /* Attribute */1) {
              if (_oldProp[0] === newProp$1[0] && _oldProp[1] === newProp$1[1] && _oldProp[2] === newProp$1[2]) {
                
              } else {
                patchVNodesOnElems_PropertiesApply_Mutate(callbacks, elem, idx, _oldProp, newProp$1);
              }
              _newProperties = newProperties[1];
              _oldProperties = oldProperties[1];
              _idx = idx + 1 | 0;
              continue ;
            }
            break;
        case /* Data */2 :
            var newProp$2 = newProperties[0];
            if (typeof newProp$2 !== "number" && newProp$2.tag === /* Data */2) {
              if (_oldProp[0] === newProp$2[0] && _oldProp[1] === newProp$2[1]) {
                
              } else {
                patchVNodesOnElems_PropertiesApply_Mutate(callbacks, elem, idx, _oldProp, newProp$2);
              }
              _newProperties = newProperties[1];
              _oldProperties = oldProperties[1];
              _idx = idx + 1 | 0;
              continue ;
            }
            break;
        case /* Event */3 :
            var _newProp = newProperties[0];
            if (typeof _newProp !== "number" && _newProp.tag === /* Event */3) {
              eventHandler_Mutate(callbacks, elem, _oldProp[0], _newProp[0], _oldProp[1], _newProp[1], _oldProp[2], _newProp[2]);
              _newProperties = newProperties[1];
              _oldProperties = oldProperties[1];
              _idx = idx + 1 | 0;
              continue ;
            }
            break;
        case /* Style */4 :
            var newProp$3 = newProperties[0];
            if (typeof newProp$3 !== "number" && newProp$3.tag === /* Style */4) {
              if (Caml_obj.caml_equal(_oldProp[0], newProp$3[0])) {
                
              } else {
                patchVNodesOnElems_PropertiesApply_Mutate(callbacks, elem, idx, _oldProp, newProp$3);
              }
              _newProperties = newProperties[1];
              _oldProperties = oldProperties[1];
              _idx = idx + 1 | 0;
              continue ;
            }
            break;
        
      }
    }
    patchVNodesOnElems_PropertiesApply_RemoveAdd(callbacks, elem, idx, _oldProp, newProperties[0]);
    _newProperties = newProperties[1];
    _oldProperties = oldProperties[1];
    _idx = idx + 1 | 0;
    continue ;
  };
}

function patchVNodesOnElems_Properties(callbacks, elem, oldProperties, newProperties) {
  return patchVNodesOnElems_PropertiesApply(callbacks, elem, 0, oldProperties, newProperties);
}

function genEmptyProps(length) {
  var _lst = /* [] */0;
  var _len = length;
  while(true) {
    var len = _len;
    var lst = _lst;
    if (len === 0) {
      return lst;
    }
    _len = len - 1 | 0;
    _lst = /* :: */[
      /* NoProp */0,
      lst
    ];
    continue ;
  };
}

function mapEmptyProps(props) {
  return List.map((function (param) {
                return /* NoProp */0;
              }), props);
}

function patchVNodesOnElems_ReplaceNode(callbacks, elem, elems, idx, param) {
  if (param.tag === /* Node */2) {
    var newProperties = param[4];
    var oldChild = Caml_array.caml_array_get(elems, idx);
    var newChild = Web_document.createElementNsOptional(param[0], param[1]);
    var match = patchVNodesOnElems_Properties(callbacks, newChild, List.map((function (param) {
                return /* NoProp */0;
              }), newProperties), newProperties);
    if (match) {
      var childChildren = newChild.childNodes;
      patchVNodesOnElems(callbacks, newChild, childChildren, 0, /* [] */0, param[5]);
      Web_node.insertBefore(elem, newChild, oldChild);
      elem.removeChild(oldChild);
      return ;
    }
    throw [
          Caml_builtin_exceptions.match_failure,
          /* tuple */[
            "vdom.ml",
            343,
            13
          ]
        ];
  }
  throw [
        Caml_builtin_exceptions.failure,
        "Node replacement should never be passed anything but a node itself"
      ];
}

function patchVNodesOnElems_CreateElement(_callbacks, _s) {
  while(true) {
    var s = _s;
    var callbacks = _callbacks;
    switch (s.tag | 0) {
      case /* CommentNode */0 :
          var text = s[0];
          return document.createComment(text);
      case /* Text */1 :
          var text$1 = s[0];
          return document.createTextNode(text$1);
      case /* Node */2 :
          var newProperties = s[4];
          var newChild = Web_document.createElementNsOptional(s[0], s[1]);
          var match = patchVNodesOnElems_Properties(callbacks, newChild, List.map((function (param) {
                      return /* NoProp */0;
                    }), newProperties), newProperties);
          if (match) {
            var childChildren = newChild.childNodes;
            patchVNodesOnElems(callbacks, newChild, childChildren, 0, /* [] */0, s[5]);
            return newChild;
          }
          throw [
                Caml_builtin_exceptions.match_failure,
                /* tuple */[
                  "vdom.ml",
                  368,
                  11
                ]
              ];
      case /* LazyGen */3 :
          var vdom = Curry._1(s[1], undefined);
          s[2].contents = vdom;
          _s = vdom;
          continue ;
      case /* Tagger */4 :
          _s = s[1];
          _callbacks = Curry._1(s[0], callbacks);
          continue ;
      
    }
  };
}

function patchVNodesOnElems_MutateNode(callbacks, elem, elems, idx, oldNode, newNode) {
  if (oldNode.tag === /* Node */2) {
    if (newNode.tag === /* Node */2) {
      if (oldNode[3] !== newNode[3] || oldNode[1] !== newNode[1]) {
        return patchVNodesOnElems_ReplaceNode(callbacks, elem, elems, idx, newNode);
      }
      var child = Caml_array.caml_array_get(elems, idx);
      var childChildren = child.childNodes;
      if (patchVNodesOnElems_Properties(callbacks, child, oldNode[4], newNode[4])) {
        
      } else {
        console.log("VDom:  Failed swapping properties because the property list length changed, use `noProp` to swap properties instead, not by altering the list structure.  This is a massive inefficiency until this issue is resolved.");
        patchVNodesOnElems_ReplaceNode(callbacks, elem, elems, idx, newNode);
      }
      return patchVNodesOnElems(callbacks, child, childChildren, 0, oldNode[5], newNode[5]);
    }
    throw [
          Caml_builtin_exceptions.failure,
          "Non-node passed to patchVNodesOnElems_MutateNode"
        ];
  }
  throw [
        Caml_builtin_exceptions.failure,
        "Non-node passed to patchVNodesOnElems_MutateNode"
      ];
}

function patchVNodesOnElems(callbacks, elem, elems, _idx, _oldVNodes, _newVNodes) {
  while(true) {
    var newVNodes = _newVNodes;
    var oldVNodes = _oldVNodes;
    var idx = _idx;
    if (oldVNodes) {
      var oldNode = oldVNodes[0];
      switch (oldNode.tag | 0) {
        case /* CommentNode */0 :
            if (newVNodes) {
              var newS = newVNodes[0];
              if (!newS.tag && oldNode[0] === newS[0]) {
                _newVNodes = newVNodes[1];
                _oldVNodes = oldVNodes[1];
                _idx = idx + 1 | 0;
                continue ;
              }
              
            }
            break;
        case /* Text */1 :
            if (newVNodes) {
              var newText = newVNodes[0];
              if (newText.tag === /* Text */1) {
                var newText$1 = newText[0];
                if (oldNode[0] !== newText$1) {
                  var child = Caml_array.caml_array_get(elems, idx);
                  child.nodeValue = newText$1;
                }
                _newVNodes = newVNodes[1];
                _oldVNodes = oldVNodes[1];
                _idx = idx + 1 | 0;
                continue ;
              }
              
            }
            break;
        case /* Node */2 :
            if (newVNodes) {
              var newNode = newVNodes[0];
              if (newNode.tag === /* Node */2) {
                var newRest = newVNodes[1];
                var newKey = newNode[2];
                var newTagName = newNode[1];
                var newNamespace = newNode[0];
                var oldRest = oldVNodes[1];
                var oldKey = oldNode[2];
                var oldTagName = oldNode[1];
                var oldNamespace = oldNode[0];
                if (oldKey === newKey && oldKey !== "") {
                  _newVNodes = newRest;
                  _oldVNodes = oldRest;
                  _idx = idx + 1 | 0;
                  continue ;
                }
                if (oldKey === "" || newKey === "") {
                  patchVNodesOnElems_MutateNode(callbacks, elem, elems, idx, oldNode, newNode);
                  _newVNodes = newRest;
                  _oldVNodes = oldRest;
                  _idx = idx + 1 | 0;
                  continue ;
                }
                var exit = 0;
                var exit$1 = 0;
                if (oldRest) {
                  var match = oldRest[0];
                  if (match.tag === /* Node */2) {
                    var olderRest = oldRest[1];
                    var olderKey = match[2];
                    var olderTagName = match[1];
                    var olderNamespace = match[0];
                    var exit$2 = 0;
                    if (newRest) {
                      var match$1 = newRest[0];
                      if (match$1.tag === /* Node */2) {
                        if (olderNamespace === newNamespace && olderTagName === newTagName && olderKey === newKey && oldNamespace === match$1[0] && oldTagName === match$1[1] && oldKey === match$1[2]) {
                          var firstChild = Caml_array.caml_array_get(elems, idx);
                          var secondChild = Caml_array.caml_array_get(elems, idx + 1 | 0);
                          elem.removeChild(secondChild);
                          Web_node.insertBefore(elem, secondChild, firstChild);
                          _newVNodes = newRest[1];
                          _oldVNodes = olderRest;
                          _idx = idx + 2 | 0;
                          continue ;
                        }
                        exit$2 = 4;
                      } else {
                        exit$2 = 4;
                      }
                    } else {
                      exit$2 = 4;
                    }
                    if (exit$2 === 4) {
                      if (olderNamespace === newNamespace && olderTagName === newTagName && olderKey === newKey) {
                        var oldChild = Caml_array.caml_array_get(elems, idx);
                        elem.removeChild(oldChild);
                        _newVNodes = newRest;
                        _oldVNodes = olderRest;
                        _idx = idx + 1 | 0;
                        continue ;
                      }
                      exit$1 = 3;
                    }
                    
                  } else {
                    exit$1 = 3;
                  }
                } else {
                  exit$1 = 3;
                }
                if (exit$1 === 3) {
                  if (newRest) {
                    var match$2 = newRest[0];
                    if (match$2.tag === /* Node */2) {
                      if (oldNamespace === match$2[0] && oldTagName === match$2[1] && oldKey === match$2[2]) {
                        var oldChild$1 = Caml_array.caml_array_get(elems, idx);
                        var newChild = patchVNodesOnElems_CreateElement(callbacks, newNode);
                        Web_node.insertBefore(elem, newChild, oldChild$1);
                        _newVNodes = newRest;
                        _idx = idx + 1 | 0;
                        continue ;
                      }
                      exit = 2;
                    } else {
                      exit = 2;
                    }
                  } else {
                    exit = 2;
                  }
                }
                if (exit === 2) {
                  patchVNodesOnElems_MutateNode(callbacks, elem, elems, idx, oldNode, newNode);
                  _newVNodes = newRest;
                  _oldVNodes = oldRest;
                  _idx = idx + 1 | 0;
                  continue ;
                }
                
              }
              
            }
            break;
        case /* LazyGen */3 :
            if (newVNodes) {
              var match$3 = newVNodes[0];
              if (match$3.tag === /* LazyGen */3) {
                var newRest$1 = newVNodes[1];
                var newCache = match$3[2];
                var newGen = match$3[1];
                var newKey$1 = match$3[0];
                var oldRest$1 = oldVNodes[1];
                var oldCache = oldNode[2];
                var oldKey$1 = oldNode[0];
                if (oldKey$1 === newKey$1) {
                  newCache.contents = oldCache.contents;
                  _newVNodes = newRest$1;
                  _oldVNodes = oldRest$1;
                  _idx = idx + 1 | 0;
                  continue ;
                }
                var exit$3 = 0;
                var exit$4 = 0;
                if (oldRest$1) {
                  var match$4 = oldRest$1[0];
                  if (match$4.tag === /* LazyGen */3) {
                    var olderRest$1 = oldRest$1[1];
                    var olderKey$1 = match$4[0];
                    var exit$5 = 0;
                    if (newRest$1) {
                      var match$5 = newRest$1[0];
                      if (match$5.tag === /* LazyGen */3) {
                        if (olderKey$1 === newKey$1 && oldKey$1 === match$5[0]) {
                          var firstChild$1 = Caml_array.caml_array_get(elems, idx);
                          var secondChild$1 = Caml_array.caml_array_get(elems, idx + 1 | 0);
                          elem.removeChild(secondChild$1);
                          Web_node.insertBefore(elem, secondChild$1, firstChild$1);
                          _newVNodes = newRest$1[1];
                          _oldVNodes = olderRest$1;
                          _idx = idx + 2 | 0;
                          continue ;
                        }
                        exit$5 = 4;
                      } else {
                        exit$5 = 4;
                      }
                    } else {
                      exit$5 = 4;
                    }
                    if (exit$5 === 4) {
                      if (olderKey$1 === newKey$1) {
                        var oldChild$2 = Caml_array.caml_array_get(elems, idx);
                        elem.removeChild(oldChild$2);
                        var oldVdom = match$4[2].contents;
                        newCache.contents = oldVdom;
                        _newVNodes = newRest$1;
                        _oldVNodes = olderRest$1;
                        _idx = idx + 1 | 0;
                        continue ;
                      }
                      exit$4 = 3;
                    }
                    
                  } else {
                    exit$4 = 3;
                  }
                } else {
                  exit$4 = 3;
                }
                if (exit$4 === 3) {
                  if (newRest$1) {
                    var match$6 = newRest$1[0];
                    if (match$6.tag === /* LazyGen */3) {
                      if (match$6[0] === oldKey$1) {
                        var oldChild$3 = Caml_array.caml_array_get(elems, idx);
                        var newVdom = Curry._1(newGen, undefined);
                        newCache.contents = newVdom;
                        var newChild$1 = patchVNodesOnElems_CreateElement(callbacks, newVdom);
                        Web_node.insertBefore(elem, newChild$1, oldChild$3);
                        _newVNodes = newRest$1;
                        _idx = idx + 1 | 0;
                        continue ;
                      }
                      exit$3 = 2;
                    } else {
                      exit$3 = 2;
                    }
                  } else {
                    exit$3 = 2;
                  }
                }
                if (exit$3 === 2) {
                  var oldVdom$1 = oldCache.contents;
                  var newVdom$1 = Curry._1(newGen, undefined);
                  newCache.contents = newVdom$1;
                  _newVNodes = /* :: */[
                    newVdom$1,
                    newRest$1
                  ];
                  _oldVNodes = /* :: */[
                    oldVdom$1,
                    oldRest$1
                  ];
                  continue ;
                }
                
              }
              
            }
            break;
        case /* Tagger */4 :
            _oldVNodes = /* :: */[
              oldNode[1],
              oldVNodes[1]
            ];
            continue ;
        
      }
      var oldRest$2 = oldVNodes[1];
      if (newVNodes) {
        var newNode$1 = newVNodes[0];
        if (newNode$1.tag === /* Tagger */4) {
          patchVNodesOnElems(Curry._1(newNode$1[0], callbacks), elem, elems, idx, /* :: */[
                oldNode,
                /* [] */0
              ], /* :: */[
                newNode$1[1],
                /* [] */0
              ]);
          _newVNodes = newVNodes[1];
          _oldVNodes = oldRest$2;
          _idx = idx + 1 | 0;
          continue ;
        }
        var oldChild$4 = Caml_array.caml_array_get(elems, idx);
        var newChild$2 = patchVNodesOnElems_CreateElement(callbacks, newNode$1);
        Web_node.insertBefore(elem, newChild$2, oldChild$4);
        elem.removeChild(oldChild$4);
        _newVNodes = newVNodes[1];
        _oldVNodes = oldRest$2;
        _idx = idx + 1 | 0;
        continue ;
      }
      var child$1 = Caml_array.caml_array_get(elems, idx);
      elem.removeChild(child$1);
      _newVNodes = /* [] */0;
      _oldVNodes = oldRest$2;
      continue ;
    }
    if (!newVNodes) {
      return ;
    }
    var newChild$3 = patchVNodesOnElems_CreateElement(callbacks, newVNodes[0]);
    elem.appendChild(newChild$3);
    _newVNodes = newVNodes[1];
    _oldVNodes = /* [] */0;
    _idx = idx + 1 | 0;
    continue ;
  };
}

function patchVNodesIntoElement(callbacks, elem, oldVNodes, newVNodes) {
  var elems = elem.childNodes;
  patchVNodesOnElems(callbacks, elem, elems, 0, oldVNodes, newVNodes);
  return newVNodes;
}

function patchVNodeIntoElement(callbacks, elem, oldVNode, newVNode) {
  return patchVNodesIntoElement(callbacks, elem, /* :: */[
              oldVNode,
              /* [] */0
            ], /* :: */[
              newVNode,
              /* [] */0
            ]);
}

function wrapCallbacks_On(func, msg) {
  if (typeof msg === "number") {
    return /* Render */0;
  } else if (msg.tag) {
    return /* RemoveRenderMsg */Block.__(1, [Curry._1(func, msg[0])]);
  } else {
    return /* AddRenderMsg */Block.__(0, [Curry._1(func, msg[0])]);
  }
}

function wrapCallbacks(func, callbacks) {
  return {
          contents: {
            enqueue: (function (msg) {
                return Curry._1(callbacks.contents.enqueue, Curry._1(func, msg));
              }),
            on: (function (smsg) {
                return Curry._1(callbacks.contents.on, wrapCallbacks_On(func, smsg));
              })
          }
        };
}

function map(func, vdom) {
  var tagger = function (param) {
    return wrapCallbacks(func, param);
  };
  return /* Tagger */Block.__(4, [
            tagger,
            vdom
          ]);
}

var noProp = /* NoProp */0;

exports.noNode = noNode;
exports.comment = comment;
exports.text = text;
exports.fullnode = fullnode;
exports.node = node;
exports.lazyGen = lazyGen;
exports.noProp = noProp;
exports.prop = prop;
exports.onCB = onCB;
exports.onMsg = onMsg;
exports.attribute = attribute;
exports.data = data;
exports.style = style;
exports.styles = styles;
exports.renderToHtmlString = renderToHtmlString;
exports.emptyEventHandler = emptyEventHandler;
exports.emptyEventCB = emptyEventCB;
exports.eventHandler = eventHandler;
exports.eventHandler_GetCB = eventHandler_GetCB;
exports.compareEventHandlerTypes = compareEventHandlerTypes;
exports.eventHandler_Register = eventHandler_Register;
exports.eventHandler_Unregister = eventHandler_Unregister;
exports.eventHandler_Mutate = eventHandler_Mutate;
exports.patchVNodesOnElems_PropertiesApply_Add = patchVNodesOnElems_PropertiesApply_Add;
exports.patchVNodesOnElems_PropertiesApply_Remove = patchVNodesOnElems_PropertiesApply_Remove;
exports.patchVNodesOnElems_PropertiesApply_RemoveAdd = patchVNodesOnElems_PropertiesApply_RemoveAdd;
exports.patchVNodesOnElems_PropertiesApply_Mutate = patchVNodesOnElems_PropertiesApply_Mutate;
exports.patchVNodesOnElems_PropertiesApply = patchVNodesOnElems_PropertiesApply;
exports.patchVNodesOnElems_Properties = patchVNodesOnElems_Properties;
exports.genEmptyProps = genEmptyProps;
exports.mapEmptyProps = mapEmptyProps;
exports.patchVNodesOnElems_ReplaceNode = patchVNodesOnElems_ReplaceNode;
exports.patchVNodesOnElems_CreateElement = patchVNodesOnElems_CreateElement;
exports.patchVNodesOnElems_MutateNode = patchVNodesOnElems_MutateNode;
exports.patchVNodesOnElems = patchVNodesOnElems;
exports.patchVNodesIntoElement = patchVNodesIntoElement;
exports.patchVNodeIntoElement = patchVNodeIntoElement;
exports.wrapCallbacks_On = wrapCallbacks_On;
exports.wrapCallbacks = wrapCallbacks;
exports.map = map;
/* No side effect */
