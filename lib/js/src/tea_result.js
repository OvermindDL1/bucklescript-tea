// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require("rescript/lib/js/caml_option.js");

function result_to_option(x) {
  if (x.TAG === /* Ok */0) {
    return Caml_option.some(x._0);
  }
  
}

function option_of_result(x) {
  if (x.TAG === /* Ok */0) {
    return Caml_option.some(x._0);
  }
  
}

function ok(x) {
  if (x.TAG === /* Ok */0) {
    return Caml_option.some(x._0);
  }
  
}

function error(x) {
  if (x.TAG === /* Ok */0) {
    return ;
  } else {
    return Caml_option.some(x._0);
  }
}

function last_of(_x) {
  while(true) {
    var x = _x;
    if (x) {
      var tl = x.tl;
      var last = x.hd;
      if (!tl) {
        return last;
      }
      if (last.TAG !== /* Ok */0) {
        return last;
      }
      _x = tl;
      continue ;
    }
    throw {
          RE_EXN_ID: "Failure",
          _1: "`Tea.Result.do` must never be passed the empty list",
          Error: new Error()
        };
  };
}

function accumulate(x) {
  if (!x) {
    return {
            TAG: /* Ok */0,
            _0: /* [] */0
          };
  }
  var tl = x.tl;
  var last = x.hd;
  if (!tl) {
    if (last.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: {
                hd: last._0,
                tl: /* [] */0
              }
            };
    } else {
      return last;
    }
  }
  if (last.TAG !== /* Ok */0) {
    return last;
  }
  var e = accumulate(tl);
  if (e.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: {
              hd: last._0,
              tl: e._0
            }
          };
  } else {
    return e;
  }
}

function first(fst, x) {
  if (x.TAG === /* Ok */0) {
    return fst;
  } else {
    return x;
  }
}

function error_of_any(_x) {
  while(true) {
    var x = _x;
    if (!x) {
      return ;
    }
    var hd = x.hd;
    if (hd.TAG !== /* Ok */0) {
      return Caml_option.some(hd._0);
    }
    _x = x.tl;
    continue ;
  };
}

function error_of_first(fst, x) {
  if (x.TAG === /* Ok */0) {
    return error(fst);
  } else {
    return Caml_option.some(x._0);
  }
}

exports.result_to_option = result_to_option;
exports.option_of_result = option_of_result;
exports.ok = ok;
exports.error = error;
exports.last_of = last_of;
exports.accumulate = accumulate;
exports.first = first;
exports.error_of_any = error_of_any;
exports.error_of_first = error_of_first;
/* No side effect */
