// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("rescript/lib/js/list.js");
var Curry = require("rescript/lib/js/curry.js");
var $$String = require("rescript/lib/js/string.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Web_node = require("./web_node.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Web_document = require("./web_document.js");

var noNode = {
  TAG: /* CommentNode */0,
  _0: ""
};

function comment(s) {
  return {
          TAG: /* CommentNode */0,
          _0: s
        };
}

function text(s) {
  return {
          TAG: /* Text */1,
          _0: s
        };
}

function fullnode(namespace, tagName, key, unique, props, vdoms) {
  return {
          TAG: /* Node */2,
          _0: namespace,
          _1: tagName,
          _2: key,
          _3: unique,
          _4: props,
          _5: vdoms
        };
}

function node(namespaceOpt, tagName, keyOpt, uniqueOpt, props, vdoms) {
  var namespace = namespaceOpt !== undefined ? namespaceOpt : "";
  var key = keyOpt !== undefined ? keyOpt : "";
  var unique = uniqueOpt !== undefined ? uniqueOpt : "";
  return fullnode(namespace, tagName, key, unique, props, vdoms);
}

function lazyGen(key, fn) {
  return {
          TAG: /* LazyGen */3,
          _0: key,
          _1: fn,
          _2: {
            contents: noNode
          }
        };
}

function prop(key, value) {
  return {
          TAG: /* RawProp */0,
          _0: key,
          _1: value
        };
}

function onCB(name, key, cb) {
  return {
          TAG: /* Event */3,
          _0: name,
          _1: {
            TAG: /* EventHandlerCallback */0,
            _0: key,
            _1: cb
          },
          _2: {
            contents: undefined
          }
        };
}

function onMsg(name, msg) {
  return {
          TAG: /* Event */3,
          _0: name,
          _1: {
            TAG: /* EventHandlerMsg */1,
            _0: msg
          },
          _2: {
            contents: undefined
          }
        };
}

function attribute(namespace, key, value) {
  return {
          TAG: /* Attribute */1,
          _0: namespace,
          _1: key,
          _2: value
        };
}

function data(key, value) {
  return {
          TAG: /* Data */2,
          _0: key,
          _1: value
        };
}

function style(key, value) {
  return {
          TAG: /* Style */4,
          _0: {
            hd: [
              key,
              value
            ],
            tl: /* [] */0
          }
        };
}

function styles(s) {
  return {
          TAG: /* Style */4,
          _0: s
        };
}

function renderToHtmlString(_x) {
  while(true) {
    var x = _x;
    switch (x.TAG | 0) {
      case /* CommentNode */0 :
          return "<!-- " + (x._0 + " -->");
      case /* Text */1 :
          return x._0;
      case /* Node */2 :
          var tagName = x._1;
          var namespace = x._0;
          return $$String.concat("", {
                      hd: "<",
                      tl: {
                        hd: namespace,
                        tl: {
                          hd: namespace === "" ? "" : ":",
                          tl: {
                            hd: tagName,
                            tl: {
                              hd: $$String.concat("", List.map((function (p) {
                                          if (typeof p === "number") {
                                            return "";
                                          }
                                          switch (p.TAG | 0) {
                                            case /* RawProp */0 :
                                                return $$String.concat("", {
                                                            hd: " ",
                                                            tl: {
                                                              hd: p._0,
                                                              tl: {
                                                                hd: "=\"",
                                                                tl: {
                                                                  hd: p._1,
                                                                  tl: {
                                                                    hd: "\"",
                                                                    tl: /* [] */0
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          });
                                            case /* Attribute */1 :
                                                return $$String.concat("", {
                                                            hd: " ",
                                                            tl: {
                                                              hd: p._1,
                                                              tl: {
                                                                hd: "=\"",
                                                                tl: {
                                                                  hd: p._2,
                                                                  tl: {
                                                                    hd: "\"",
                                                                    tl: /* [] */0
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          });
                                            case /* Data */2 :
                                                return $$String.concat("", {
                                                            hd: " data-",
                                                            tl: {
                                                              hd: p._0,
                                                              tl: {
                                                                hd: "=\"",
                                                                tl: {
                                                                  hd: p._1,
                                                                  tl: {
                                                                    hd: "\"",
                                                                    tl: /* [] */0
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          });
                                            case /* Event */3 :
                                                return "";
                                            case /* Style */4 :
                                                return $$String.concat("", {
                                                            hd: " style=\"",
                                                            tl: {
                                                              hd: $$String.concat(";", List.map((function (param) {
                                                                          return $$String.concat("", {
                                                                                      hd: param[0],
                                                                                      tl: {
                                                                                        hd: ":",
                                                                                        tl: {
                                                                                          hd: param[1],
                                                                                          tl: {
                                                                                            hd: ";",
                                                                                            tl: /* [] */0
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    });
                                                                        }), p._0)),
                                                              tl: {
                                                                hd: "\"",
                                                                tl: /* [] */0
                                                              }
                                                            }
                                                          });
                                            
                                          }
                                        }), x._4)),
                              tl: {
                                hd: ">",
                                tl: {
                                  hd: $$String.concat("", List.map(renderToHtmlString, x._5)),
                                  tl: {
                                    hd: "</",
                                    tl: {
                                      hd: tagName,
                                      tl: {
                                        hd: ">",
                                        tl: /* [] */0
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    });
      case /* LazyGen */3 :
          _x = Curry._1(x._1, undefined);
          continue ;
      case /* Tagger */4 :
          _x = x._1;
          continue ;
      
    }
  };
}

function emptyEventHandler(_ev) {
  
}

function emptyEventCB(_ev) {
  
}

function eventHandler(callbacks, cb) {
  return function (ev) {
    var msg = Curry._1(cb.contents, ev);
    if (msg !== undefined) {
      return Curry._1(callbacks.contents.enqueue, Caml_option.valFromOption(msg));
    }
    
  };
}

function eventHandler_GetCB(x) {
  if (x.TAG === /* EventHandlerCallback */0) {
    return x._1;
  }
  var msg = x._0;
  return function (_ev) {
    return Caml_option.some(msg);
  };
}

function compareEventHandlerTypes(left, x) {
  if (x.TAG === /* EventHandlerCallback */0) {
    if (left.TAG === /* EventHandlerCallback */0) {
      return x._0 === left._0;
    } else {
      return false;
    }
  } else if (left.TAG === /* EventHandlerCallback */0 || !Caml_obj.caml_equal(x._0, left._0)) {
    return false;
  } else {
    return true;
  }
}

function eventHandler_Register(callbacks, elem, name, handlerType) {
  var cb = {
    contents: eventHandler_GetCB(handlerType)
  };
  var handler = eventHandler(callbacks, cb);
  Web_node.addEventListener(elem, name, handler, false);
  return {
          handler: handler,
          cb: cb
        };
}

function eventHandler_Unregister(elem, name, x) {
  if (x !== undefined) {
    Web_node.removeEventListener(elem, name, x.handler, false);
    return ;
  }
  
}

function eventHandler_Mutate(callbacks, elem, oldName, newName, oldHandlerType, newHandlerType, oldCache, newCache) {
  var oldcache = oldCache.contents;
  if (oldcache === undefined) {
    newCache.contents = eventHandler_Register(callbacks, elem, newName, newHandlerType);
    return ;
  }
  if (oldName === newName) {
    newCache.contents = oldCache.contents;
    if (compareEventHandlerTypes(oldHandlerType, newHandlerType)) {
      return ;
    }
    var cb = eventHandler_GetCB(newHandlerType);
    oldcache.cb.contents = cb;
    return ;
  }
  oldCache.contents = eventHandler_Unregister(elem, oldName, oldCache.contents);
  newCache.contents = eventHandler_Register(callbacks, elem, newName, newHandlerType);
  
}

function patchVNodesOnElems_PropertiesApply_Add(callbacks, elem, _idx, x) {
  if (typeof x === "number") {
    return ;
  }
  switch (x.TAG | 0) {
    case /* RawProp */0 :
        elem[x._0] = x._1;
        return ;
    case /* Attribute */1 :
        return Web_node.setAttributeNsOptional(elem, x._0, x._1, x._2);
    case /* Data */2 :
        console.log([
              "TODO:  Add Data Unhandled",
              x._0,
              x._1
            ]);
        throw {
              RE_EXN_ID: "Failure",
              _1: "TODO:  Add Data Unhandled",
              Error: new Error()
            };
    case /* Event */3 :
        x._2.contents = eventHandler_Register(callbacks, elem, x._0, x._1);
        return ;
    case /* Style */4 :
        return List.fold_left((function (param, param$1) {
                      return Web_node.setStyleProperty(elem, undefined, param$1[0], param$1[1]);
                    }), undefined, x._0);
    
  }
}

function patchVNodesOnElems_PropertiesApply_Remove(_callbacks, elem, _idx, x) {
  if (typeof x === "number") {
    return ;
  }
  switch (x.TAG | 0) {
    case /* RawProp */0 :
        elem[x._0] = undefined;
        return ;
    case /* Attribute */1 :
        return Web_node.removeAttributeNsOptional(elem, x._0, x._1);
    case /* Data */2 :
        console.log([
              "TODO:  Remove Data Unhandled",
              x._0,
              x._1
            ]);
        throw {
              RE_EXN_ID: "Failure",
              _1: "TODO:  Remove Data Unhandled",
              Error: new Error()
            };
    case /* Event */3 :
        var cache = x._2;
        cache.contents = eventHandler_Unregister(elem, x._0, cache.contents);
        return ;
    case /* Style */4 :
        return List.fold_left((function (param, param$1) {
                      return Web_node.setStyleProperty(elem, undefined, param$1[0], null);
                    }), undefined, x._0);
    
  }
}

function patchVNodesOnElems_PropertiesApply_RemoveAdd(callbacks, elem, idx, oldProp, newProp) {
  patchVNodesOnElems_PropertiesApply_Remove(callbacks, elem, idx, oldProp);
  patchVNodesOnElems_PropertiesApply_Add(callbacks, elem, idx, newProp);
  
}

function patchVNodesOnElems_PropertiesApply_Mutate(_callbacks, elem, _idx, oldProp, x) {
  if (typeof x === "number") {
    throw {
          RE_EXN_ID: "Failure",
          _1: "This should never be called as all entries through NoProp are gated.",
          Error: new Error()
        };
  }
  switch (x.TAG | 0) {
    case /* RawProp */0 :
        elem[x._0] = x._1;
        return ;
    case /* Attribute */1 :
        return Web_node.setAttributeNsOptional(elem, x._0, x._1, x._2);
    case /* Data */2 :
        console.log([
              "TODO:  Mutate Data Unhandled",
              x._0,
              x._1
            ]);
        throw {
              RE_EXN_ID: "Failure",
              _1: "TODO:  Mutate Data Unhandled",
              Error: new Error()
            };
    case /* Event */3 :
        throw {
              RE_EXN_ID: "Failure",
              _1: "This will never be called because it is gated",
              Error: new Error()
            };
    case /* Style */4 :
        if (typeof oldProp === "number") {
          throw {
                RE_EXN_ID: "Failure",
                _1: "Passed a non-Style to a new Style as a Mutations while the old Style is not actually a style!",
                Error: new Error()
              };
        }
        if (oldProp.TAG === /* Style */4) {
          return List.fold_left2((function (param, param$1, param$2) {
                        var nv = param$2[1];
                        var nk = param$2[0];
                        var ok = param$1[0];
                        if (ok === nk) {
                          if (param$1[1] === nv) {
                            return ;
                          } else {
                            return Web_node.setStyleProperty(elem, undefined, nk, nv);
                          }
                        } else {
                          Web_node.setStyleProperty(elem, undefined, ok, null);
                          return Web_node.setStyleProperty(elem, undefined, nk, nv);
                        }
                      }), undefined, oldProp._0, x._0);
        }
        throw {
              RE_EXN_ID: "Failure",
              _1: "Passed a non-Style to a new Style as a Mutations while the old Style is not actually a style!",
              Error: new Error()
            };
    
  }
}

function patchVNodesOnElems_PropertiesApply(callbacks, elem, _idx, _oldProperties, _newProperties) {
  while(true) {
    var newProperties = _newProperties;
    var oldProperties = _oldProperties;
    var idx = _idx;
    if (!oldProperties) {
      if (newProperties) {
        return false;
      } else {
        return true;
      }
    }
    var _oldProp = oldProperties.hd;
    if (!newProperties) {
      return false;
    }
    if (typeof _oldProp === "number") {
      if (typeof newProperties.hd === "number") {
        _newProperties = newProperties.tl;
        _oldProperties = oldProperties.tl;
        _idx = idx + 1 | 0;
        continue ;
      }
      
    } else {
      switch (_oldProp.TAG | 0) {
        case /* RawProp */0 :
            var newProp = newProperties.hd;
            if (typeof newProp !== "number" && newProp.TAG === /* RawProp */0) {
              if (_oldProp._0 === newProp._0 && _oldProp._1 === newProp._1) {
                
              } else {
                patchVNodesOnElems_PropertiesApply_Mutate(callbacks, elem, idx, _oldProp, newProp);
              }
              _newProperties = newProperties.tl;
              _oldProperties = oldProperties.tl;
              _idx = idx + 1 | 0;
              continue ;
            }
            break;
        case /* Attribute */1 :
            var newProp$1 = newProperties.hd;
            if (typeof newProp$1 !== "number" && newProp$1.TAG === /* Attribute */1) {
              if (_oldProp._0 === newProp$1._0 && _oldProp._1 === newProp$1._1 && _oldProp._2 === newProp$1._2) {
                
              } else {
                patchVNodesOnElems_PropertiesApply_Mutate(callbacks, elem, idx, _oldProp, newProp$1);
              }
              _newProperties = newProperties.tl;
              _oldProperties = oldProperties.tl;
              _idx = idx + 1 | 0;
              continue ;
            }
            break;
        case /* Data */2 :
            var newProp$2 = newProperties.hd;
            if (typeof newProp$2 !== "number" && newProp$2.TAG === /* Data */2) {
              if (_oldProp._0 === newProp$2._0 && _oldProp._1 === newProp$2._1) {
                
              } else {
                patchVNodesOnElems_PropertiesApply_Mutate(callbacks, elem, idx, _oldProp, newProp$2);
              }
              _newProperties = newProperties.tl;
              _oldProperties = oldProperties.tl;
              _idx = idx + 1 | 0;
              continue ;
            }
            break;
        case /* Event */3 :
            var _newProp = newProperties.hd;
            if (typeof _newProp !== "number" && _newProp.TAG === /* Event */3) {
              eventHandler_Mutate(callbacks, elem, _oldProp._0, _newProp._0, _oldProp._1, _newProp._1, _oldProp._2, _newProp._2);
              _newProperties = newProperties.tl;
              _oldProperties = oldProperties.tl;
              _idx = idx + 1 | 0;
              continue ;
            }
            break;
        case /* Style */4 :
            var newProp$3 = newProperties.hd;
            if (typeof newProp$3 !== "number" && newProp$3.TAG === /* Style */4) {
              if (Caml_obj.caml_equal(_oldProp._0, newProp$3._0)) {
                
              } else {
                patchVNodesOnElems_PropertiesApply_Mutate(callbacks, elem, idx, _oldProp, newProp$3);
              }
              _newProperties = newProperties.tl;
              _oldProperties = oldProperties.tl;
              _idx = idx + 1 | 0;
              continue ;
            }
            break;
        
      }
    }
    patchVNodesOnElems_PropertiesApply_RemoveAdd(callbacks, elem, idx, _oldProp, newProperties.hd);
    _newProperties = newProperties.tl;
    _oldProperties = oldProperties.tl;
    _idx = idx + 1 | 0;
    continue ;
  };
}

function patchVNodesOnElems_Properties(callbacks, elem, oldProperties, newProperties) {
  return patchVNodesOnElems_PropertiesApply(callbacks, elem, 0, oldProperties, newProperties);
}

function genEmptyProps(length) {
  var _lst = /* [] */0;
  var _x = length;
  while(true) {
    var x = _x;
    var lst = _lst;
    if (x === 0) {
      return lst;
    }
    _x = x - 1 | 0;
    _lst = {
      hd: /* NoProp */0,
      tl: lst
    };
    continue ;
  };
}

function mapEmptyProps(props) {
  return List.map((function (param) {
                return /* NoProp */0;
              }), props);
}

function patchVNodesOnElems_ReplaceNode(callbacks, elem, elems, idx, x) {
  if (x.TAG === /* Node */2) {
    var newProperties = x._4;
    var oldChild = Caml_array.get(elems, idx);
    var newChild = Web_document.createElementNsOptional(x._0, x._1);
    var match = patchVNodesOnElems_Properties(callbacks, newChild, List.map((function (param) {
                return /* NoProp */0;
              }), newProperties), newProperties);
    if (match) {
      var childChildren = newChild.childNodes;
      patchVNodesOnElems(callbacks, newChild, childChildren, 0, /* [] */0, x._5);
      elem.insertBefore(newChild, oldChild);
      elem.removeChild(oldChild);
      return ;
    }
    throw {
          RE_EXN_ID: "Match_failure",
          _1: [
            "vdom.res",
            378,
            10
          ],
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: "Failure",
        _1: "Node replacement should never be passed anything but a node itself",
        Error: new Error()
      };
}

function patchVNodesOnElems_CreateElement(_callbacks, _x) {
  while(true) {
    var x = _x;
    var callbacks = _callbacks;
    switch (x.TAG | 0) {
      case /* CommentNode */0 :
          var text = x._0;
          return document.createComment(text);
      case /* Text */1 :
          var text$1 = x._0;
          return document.createTextNode(text$1);
      case /* Node */2 :
          var newProperties = x._4;
          var newChild = Web_document.createElementNsOptional(x._0, x._1);
          var match = patchVNodesOnElems_Properties(callbacks, newChild, List.map((function (param) {
                      return /* NoProp */0;
                    }), newProperties), newProperties);
          if (match) {
            var childChildren = newChild.childNodes;
            patchVNodesOnElems(callbacks, newChild, childChildren, 0, /* [] */0, x._5);
            return newChild;
          }
          throw {
                RE_EXN_ID: "Match_failure",
                _1: [
                  "vdom.res",
                  401,
                  10
                ],
                Error: new Error()
              };
      case /* LazyGen */3 :
          var vdom = Curry._1(x._1, undefined);
          x._2.contents = vdom;
          _x = vdom;
          continue ;
      case /* Tagger */4 :
          _x = x._1;
          _callbacks = Curry._1(x._0, callbacks);
          continue ;
      
    }
  };
}

function patchVNodesOnElems_MutateNode(callbacks, elem, elems, idx, oldNode, newNode) {
  if (oldNode.TAG === /* Node */2) {
    if (newNode.TAG === /* Node */2) {
      if (oldNode._3 !== newNode._3 || oldNode._1 !== newNode._1) {
        return patchVNodesOnElems_ReplaceNode(callbacks, elem, elems, idx, newNode);
      }
      var child = Caml_array.get(elems, idx);
      var childChildren = child.childNodes;
      if (patchVNodesOnElems_Properties(callbacks, child, oldNode._4, newNode._4)) {
        
      } else {
        console.log("VDom:  Failed swapping properties because the property list length changed, use `noProp` to swap properties instead, not by altering the list structure.  This is a massive inefficiency until this issue is resolved.");
        patchVNodesOnElems_ReplaceNode(callbacks, elem, elems, idx, newNode);
      }
      return patchVNodesOnElems(callbacks, child, childChildren, 0, oldNode._5, newNode._5);
    }
    throw {
          RE_EXN_ID: "Failure",
          _1: "Non-node passed to patchVNodesOnElems_MutateNode",
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: "Failure",
        _1: "Non-node passed to patchVNodesOnElems_MutateNode",
        Error: new Error()
      };
}

function patchVNodesOnElems(callbacks, elem, elems, _idx, _oldVNodes, _newVNodes) {
  while(true) {
    var newVNodes = _newVNodes;
    var oldVNodes = _oldVNodes;
    var idx = _idx;
    if (oldVNodes) {
      var oldNode = oldVNodes.hd;
      switch (oldNode.TAG | 0) {
        case /* CommentNode */0 :
            if (newVNodes) {
              var newS = newVNodes.hd;
              if (newS.TAG === /* CommentNode */0 && oldNode._0 === newS._0) {
                _newVNodes = newVNodes.tl;
                _oldVNodes = oldVNodes.tl;
                _idx = idx + 1 | 0;
                continue ;
              }
              
            }
            break;
        case /* Text */1 :
            if (newVNodes) {
              var newText = newVNodes.hd;
              if (newText.TAG === /* Text */1) {
                var newText$1 = newText._0;
                if (oldNode._0 !== newText$1) {
                  var child = Caml_array.get(elems, idx);
                  child.nodeValue = newText$1;
                }
                _newVNodes = newVNodes.tl;
                _oldVNodes = oldVNodes.tl;
                _idx = idx + 1 | 0;
                continue ;
              }
              
            }
            break;
        case /* Node */2 :
            if (newVNodes) {
              var newNode = newVNodes.hd;
              if (newNode.TAG === /* Node */2) {
                var newRest = newVNodes.tl;
                var newKey = newNode._2;
                var newTagName = newNode._1;
                var newNamespace = newNode._0;
                var oldRest = oldVNodes.tl;
                var oldKey = oldNode._2;
                var oldTagName = oldNode._1;
                var oldNamespace = oldNode._0;
                if (oldKey === newKey && oldKey !== "") {
                  _newVNodes = newRest;
                  _oldVNodes = oldRest;
                  _idx = idx + 1 | 0;
                  continue ;
                }
                if (oldKey === "" || newKey === "") {
                  patchVNodesOnElems_MutateNode(callbacks, elem, elems, idx, oldNode, newNode);
                  _newVNodes = newRest;
                  _oldVNodes = oldRest;
                  _idx = idx + 1 | 0;
                  continue ;
                }
                var exit = 0;
                var exit$1 = 0;
                if (oldRest) {
                  var match = oldRest.hd;
                  if (match.TAG === /* Node */2) {
                    var olderRest = oldRest.tl;
                    var olderKey = match._2;
                    var olderTagName = match._1;
                    var olderNamespace = match._0;
                    var exit$2 = 0;
                    if (newRest) {
                      var match$1 = newRest.hd;
                      if (match$1.TAG === /* Node */2) {
                        if (olderNamespace === newNamespace && olderTagName === newTagName && olderKey === newKey && oldNamespace === match$1._0 && oldTagName === match$1._1 && oldKey === match$1._2) {
                          var firstChild = Caml_array.get(elems, idx);
                          var secondChild = Caml_array.get(elems, idx + 1 | 0);
                          elem.removeChild(secondChild);
                          elem.insertBefore(secondChild, firstChild);
                          _newVNodes = newRest.tl;
                          _oldVNodes = olderRest;
                          _idx = idx + 2 | 0;
                          continue ;
                        }
                        exit$2 = 4;
                      } else {
                        exit$2 = 4;
                      }
                    } else {
                      exit$2 = 4;
                    }
                    if (exit$2 === 4) {
                      if (olderNamespace === newNamespace && olderTagName === newTagName && olderKey === newKey) {
                        var oldChild = Caml_array.get(elems, idx);
                        elem.removeChild(oldChild);
                        _newVNodes = newRest;
                        _oldVNodes = olderRest;
                        _idx = idx + 1 | 0;
                        continue ;
                      }
                      exit$1 = 3;
                    }
                    
                  } else {
                    exit$1 = 3;
                  }
                } else {
                  exit$1 = 3;
                }
                if (exit$1 === 3) {
                  if (newRest) {
                    var match$2 = newRest.hd;
                    if (match$2.TAG === /* Node */2) {
                      if (oldNamespace === match$2._0 && oldTagName === match$2._1 && oldKey === match$2._2) {
                        var oldChild$1 = Caml_array.get(elems, idx);
                        var newChild = patchVNodesOnElems_CreateElement(callbacks, newNode);
                        elem.insertBefore(newChild, oldChild$1);
                        _newVNodes = newRest;
                        _idx = idx + 1 | 0;
                        continue ;
                      }
                      exit = 2;
                    } else {
                      exit = 2;
                    }
                  } else {
                    exit = 2;
                  }
                }
                if (exit === 2) {
                  patchVNodesOnElems_MutateNode(callbacks, elem, elems, idx, oldNode, newNode);
                  _newVNodes = newRest;
                  _oldVNodes = oldRest;
                  _idx = idx + 1 | 0;
                  continue ;
                }
                
              }
              
            }
            break;
        case /* LazyGen */3 :
            if (newVNodes) {
              var match$3 = newVNodes.hd;
              if (match$3.TAG === /* LazyGen */3) {
                var newRest$1 = newVNodes.tl;
                var newCache = match$3._2;
                var newGen = match$3._1;
                var newKey$1 = match$3._0;
                var oldRest$1 = oldVNodes.tl;
                var oldCache = oldNode._2;
                var oldKey$1 = oldNode._0;
                if (oldKey$1 === newKey$1) {
                  newCache.contents = oldCache.contents;
                  _newVNodes = newRest$1;
                  _oldVNodes = oldRest$1;
                  _idx = idx + 1 | 0;
                  continue ;
                }
                var exit$3 = 0;
                var exit$4 = 0;
                if (oldRest$1) {
                  var match$4 = oldRest$1.hd;
                  if (match$4.TAG === /* LazyGen */3) {
                    var olderRest$1 = oldRest$1.tl;
                    var olderKey$1 = match$4._0;
                    var exit$5 = 0;
                    if (newRest$1) {
                      var match$5 = newRest$1.hd;
                      if (match$5.TAG === /* LazyGen */3) {
                        if (olderKey$1 === newKey$1 && oldKey$1 === match$5._0) {
                          var firstChild$1 = Caml_array.get(elems, idx);
                          var secondChild$1 = Caml_array.get(elems, idx + 1 | 0);
                          elem.removeChild(secondChild$1);
                          elem.insertBefore(secondChild$1, firstChild$1);
                          _newVNodes = newRest$1.tl;
                          _oldVNodes = olderRest$1;
                          _idx = idx + 2 | 0;
                          continue ;
                        }
                        exit$5 = 4;
                      } else {
                        exit$5 = 4;
                      }
                    } else {
                      exit$5 = 4;
                    }
                    if (exit$5 === 4) {
                      if (olderKey$1 === newKey$1) {
                        var oldChild$2 = Caml_array.get(elems, idx);
                        elem.removeChild(oldChild$2);
                        var oldVdom = match$4._2.contents;
                        newCache.contents = oldVdom;
                        _newVNodes = newRest$1;
                        _oldVNodes = olderRest$1;
                        _idx = idx + 1 | 0;
                        continue ;
                      }
                      exit$4 = 3;
                    }
                    
                  } else {
                    exit$4 = 3;
                  }
                } else {
                  exit$4 = 3;
                }
                if (exit$4 === 3) {
                  if (newRest$1) {
                    var match$6 = newRest$1.hd;
                    if (match$6.TAG === /* LazyGen */3) {
                      if (match$6._0 === oldKey$1) {
                        var oldChild$3 = Caml_array.get(elems, idx);
                        var newVdom = Curry._1(newGen, undefined);
                        newCache.contents = newVdom;
                        var newChild$1 = patchVNodesOnElems_CreateElement(callbacks, newVdom);
                        elem.insertBefore(newChild$1, oldChild$3);
                        _newVNodes = newRest$1;
                        _idx = idx + 1 | 0;
                        continue ;
                      }
                      exit$3 = 2;
                    } else {
                      exit$3 = 2;
                    }
                  } else {
                    exit$3 = 2;
                  }
                }
                if (exit$3 === 2) {
                  var oldVdom$1 = oldCache.contents;
                  var newVdom$1 = Curry._1(newGen, undefined);
                  newCache.contents = newVdom$1;
                  _newVNodes = {
                    hd: newVdom$1,
                    tl: newRest$1
                  };
                  _oldVNodes = {
                    hd: oldVdom$1,
                    tl: oldRest$1
                  };
                  continue ;
                }
                
              }
              
            }
            break;
        case /* Tagger */4 :
            _oldVNodes = {
              hd: oldNode._1,
              tl: oldVNodes.tl
            };
            continue ;
        
      }
      var oldRest$2 = oldVNodes.tl;
      if (newVNodes) {
        var newNode$1 = newVNodes.hd;
        if (newNode$1.TAG === /* Tagger */4) {
          patchVNodesOnElems(Curry._1(newNode$1._0, callbacks), elem, elems, idx, {
                hd: oldNode,
                tl: /* [] */0
              }, {
                hd: newNode$1._1,
                tl: /* [] */0
              });
          _newVNodes = newVNodes.tl;
          _oldVNodes = oldRest$2;
          _idx = idx + 1 | 0;
          continue ;
        }
        var oldChild$4 = Caml_array.get(elems, idx);
        var newChild$2 = patchVNodesOnElems_CreateElement(callbacks, newNode$1);
        elem.insertBefore(newChild$2, oldChild$4);
        elem.removeChild(oldChild$4);
        _newVNodes = newVNodes.tl;
        _oldVNodes = oldRest$2;
        _idx = idx + 1 | 0;
        continue ;
      }
      var child$1 = Caml_array.get(elems, idx);
      elem.removeChild(child$1);
      _newVNodes = /* [] */0;
      _oldVNodes = oldRest$2;
      continue ;
    }
    if (!newVNodes) {
      return ;
    }
    var newChild$3 = patchVNodesOnElems_CreateElement(callbacks, newVNodes.hd);
    elem.appendChild(newChild$3);
    _newVNodes = newVNodes.tl;
    _oldVNodes = /* [] */0;
    _idx = idx + 1 | 0;
    continue ;
  };
}

function patchVNodesIntoElement(callbacks, elem, oldVNodes, newVNodes) {
  var elems = elem.childNodes;
  patchVNodesOnElems(callbacks, elem, elems, 0, oldVNodes, newVNodes);
  return newVNodes;
}

function patchVNodeIntoElement(callbacks, elem, oldVNode, newVNode) {
  return patchVNodesIntoElement(callbacks, elem, {
              hd: oldVNode,
              tl: /* [] */0
            }, {
              hd: newVNode,
              tl: /* [] */0
            });
}

function wrapCallbacks_On(func, x) {
  if (typeof x === "number") {
    return /* Render */0;
  } else if (x.TAG === /* AddRenderMsg */0) {
    return {
            TAG: /* AddRenderMsg */0,
            _0: Curry._1(func, x._0)
          };
  } else {
    return {
            TAG: /* RemoveRenderMsg */1,
            _0: Curry._1(func, x._0)
          };
  }
}

function wrapCallbacks(func, callbacks) {
  return {
          contents: {
            enqueue: (function (msg) {
                return Curry._1(callbacks.contents.enqueue, Curry._1(func, msg));
              }),
            on: (function (smsg) {
                return Curry._1(callbacks.contents.on, wrapCallbacks_On(func, smsg));
              })
          }
        };
}

function map(func, vdom) {
  var tagger = function (param) {
    return wrapCallbacks(func, param);
  };
  return {
          TAG: /* Tagger */4,
          _0: tagger,
          _1: vdom
        };
}

var noProp = /* NoProp */0;

exports.noNode = noNode;
exports.comment = comment;
exports.text = text;
exports.fullnode = fullnode;
exports.node = node;
exports.lazyGen = lazyGen;
exports.noProp = noProp;
exports.prop = prop;
exports.onCB = onCB;
exports.onMsg = onMsg;
exports.attribute = attribute;
exports.data = data;
exports.style = style;
exports.styles = styles;
exports.renderToHtmlString = renderToHtmlString;
exports.emptyEventHandler = emptyEventHandler;
exports.emptyEventCB = emptyEventCB;
exports.eventHandler = eventHandler;
exports.eventHandler_GetCB = eventHandler_GetCB;
exports.compareEventHandlerTypes = compareEventHandlerTypes;
exports.eventHandler_Register = eventHandler_Register;
exports.eventHandler_Unregister = eventHandler_Unregister;
exports.eventHandler_Mutate = eventHandler_Mutate;
exports.patchVNodesOnElems_PropertiesApply_Add = patchVNodesOnElems_PropertiesApply_Add;
exports.patchVNodesOnElems_PropertiesApply_Remove = patchVNodesOnElems_PropertiesApply_Remove;
exports.patchVNodesOnElems_PropertiesApply_RemoveAdd = patchVNodesOnElems_PropertiesApply_RemoveAdd;
exports.patchVNodesOnElems_PropertiesApply_Mutate = patchVNodesOnElems_PropertiesApply_Mutate;
exports.patchVNodesOnElems_PropertiesApply = patchVNodesOnElems_PropertiesApply;
exports.patchVNodesOnElems_Properties = patchVNodesOnElems_Properties;
exports.genEmptyProps = genEmptyProps;
exports.mapEmptyProps = mapEmptyProps;
exports.patchVNodesOnElems_ReplaceNode = patchVNodesOnElems_ReplaceNode;
exports.patchVNodesOnElems_CreateElement = patchVNodesOnElems_CreateElement;
exports.patchVNodesOnElems_MutateNode = patchVNodesOnElems_MutateNode;
exports.patchVNodesOnElems = patchVNodesOnElems;
exports.patchVNodesIntoElement = patchVNodesIntoElement;
exports.patchVNodeIntoElement = patchVNodeIntoElement;
exports.wrapCallbacks_On = wrapCallbacks_On;
exports.wrapCallbacks = wrapCallbacks;
exports.map = map;
/* No side effect */
