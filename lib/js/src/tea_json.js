// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml = require("rescript/lib/js/caml.js");
var List = require("rescript/lib/js/list.js");
var $$Array = require("rescript/lib/js/array.js");
var Curry = require("rescript/lib/js/curry.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Web_json = require("./web_json.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Tea_result = require("./tea_result.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

function height(param) {
  if (param) {
    return param.h;
  } else {
    return 0;
  }
}

function create(l, x, d, r) {
  var hl = height(l);
  var hr = height(r);
  return /* Node */{
          l: l,
          v: x,
          d: d,
          r: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function singleton(x, d) {
  return /* Node */{
          l: /* Empty */0,
          v: x,
          d: d,
          r: /* Empty */0,
          h: 1
        };
}

function bal(l, x, d, r) {
  var hl = l ? l.h : 0;
  var hr = r ? r.h : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      var lr = l.r;
      var ld = l.d;
      var lv = l.v;
      var ll = l.l;
      if (height(ll) >= height(lr)) {
        return create(ll, lv, ld, create(lr, x, d, r));
      }
      if (lr) {
        return create(create(ll, lv, ld, lr.l), lr.v, lr.d, create(lr.r, x, d, r));
      }
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "Map.bal",
            Error: new Error()
          };
    }
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Map.bal",
          Error: new Error()
        };
  }
  if (hr <= (hl + 2 | 0)) {
    return /* Node */{
            l: l,
            v: x,
            d: d,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
  if (r) {
    var rr = r.r;
    var rd = r.d;
    var rv = r.v;
    var rl = r.l;
    if (height(rr) >= height(rl)) {
      return create(create(l, x, d, rl), rv, rd, rr);
    }
    if (rl) {
      return create(create(l, x, d, rl.l), rl.v, rl.d, create(rl.r, rv, rd, rr));
    }
    throw {
          RE_EXN_ID: "Invalid_argument",
          _1: "Map.bal",
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: "Invalid_argument",
        _1: "Map.bal",
        Error: new Error()
      };
}

function is_empty(param) {
  if (param) {
    return false;
  } else {
    return true;
  }
}

function add(x, data, m) {
  if (!m) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            d: data,
            r: /* Empty */0,
            h: 1
          };
  }
  var r = m.r;
  var d = m.d;
  var v = m.v;
  var l = m.l;
  var c = Caml.caml_string_compare(x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return /* Node */{
              l: l,
              v: x,
              d: data,
              r: r,
              h: m.h
            };
    }
  }
  if (c < 0) {
    var ll = add(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal(ll, v, d, r);
    }
  }
  var rr = add(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal(l, v, d, rr);
  }
}

function find(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var c = Caml.caml_string_compare(x, param.v);
      if (c === 0) {
        return param.d;
      }
      _param = c < 0 ? param.l : param.r;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function find_first(f, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var v = param.v;
      if (Curry._1(f, v)) {
        var _v0 = v;
        var _d0 = param.d;
        var _param$1 = param.l;
        while(true) {
          var param$1 = _param$1;
          var d0 = _d0;
          var v0 = _v0;
          if (!param$1) {
            return [
                    v0,
                    d0
                  ];
          }
          var v$1 = param$1.v;
          if (Curry._1(f, v$1)) {
            _param$1 = param$1.l;
            _d0 = param$1.d;
            _v0 = v$1;
            continue ;
          }
          _param$1 = param$1.r;
          continue ;
        };
      }
      _param = param.r;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function find_first_opt(f, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var v = param.v;
    if (Curry._1(f, v)) {
      var _v0 = v;
      var _d0 = param.d;
      var _param$1 = param.l;
      while(true) {
        var param$1 = _param$1;
        var d0 = _d0;
        var v0 = _v0;
        if (!param$1) {
          return [
                  v0,
                  d0
                ];
        }
        var v$1 = param$1.v;
        if (Curry._1(f, v$1)) {
          _param$1 = param$1.l;
          _d0 = param$1.d;
          _v0 = v$1;
          continue ;
        }
        _param$1 = param$1.r;
        continue ;
      };
    }
    _param = param.r;
    continue ;
  };
}

function find_last(f, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var v = param.v;
      if (Curry._1(f, v)) {
        var _v0 = v;
        var _d0 = param.d;
        var _param$1 = param.r;
        while(true) {
          var param$1 = _param$1;
          var d0 = _d0;
          var v0 = _v0;
          if (!param$1) {
            return [
                    v0,
                    d0
                  ];
          }
          var v$1 = param$1.v;
          if (Curry._1(f, v$1)) {
            _param$1 = param$1.r;
            _d0 = param$1.d;
            _v0 = v$1;
            continue ;
          }
          _param$1 = param$1.l;
          continue ;
        };
      }
      _param = param.l;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function find_last_opt(f, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var v = param.v;
    if (Curry._1(f, v)) {
      var _v0 = v;
      var _d0 = param.d;
      var _param$1 = param.r;
      while(true) {
        var param$1 = _param$1;
        var d0 = _d0;
        var v0 = _v0;
        if (!param$1) {
          return [
                  v0,
                  d0
                ];
        }
        var v$1 = param$1.v;
        if (Curry._1(f, v$1)) {
          _param$1 = param$1.r;
          _d0 = param$1.d;
          _v0 = v$1;
          continue ;
        }
        _param$1 = param$1.l;
        continue ;
      };
    }
    _param = param.l;
    continue ;
  };
}

function find_opt(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var c = Caml.caml_string_compare(x, param.v);
    if (c === 0) {
      return Caml_option.some(param.d);
    }
    _param = c < 0 ? param.l : param.r;
    continue ;
  };
}

function mem(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    var c = Caml.caml_string_compare(x, param.v);
    if (c === 0) {
      return true;
    }
    _param = c < 0 ? param.l : param.r;
    continue ;
  };
}

function min_binding(_param) {
  while(true) {
    var param = _param;
    if (param) {
      var l = param.l;
      if (!l) {
        return [
                param.v,
                param.d
              ];
      }
      _param = l;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function min_binding_opt(_param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var l = param.l;
    if (!l) {
      return [
              param.v,
              param.d
            ];
    }
    _param = l;
    continue ;
  };
}

function max_binding(_param) {
  while(true) {
    var param = _param;
    if (param) {
      var r = param.r;
      if (!r) {
        return [
                param.v,
                param.d
              ];
      }
      _param = r;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function max_binding_opt(_param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var r = param.r;
    if (!r) {
      return [
              param.v,
              param.d
            ];
    }
    _param = r;
    continue ;
  };
}

function remove_min_binding(param) {
  if (param) {
    var l = param.l;
    if (l) {
      return bal(remove_min_binding(l), param.v, param.d, param.r);
    } else {
      return param.r;
    }
  }
  throw {
        RE_EXN_ID: "Invalid_argument",
        _1: "Map.remove_min_elt",
        Error: new Error()
      };
}

function merge(t1, t2) {
  if (!t1) {
    return t2;
  }
  if (!t2) {
    return t1;
  }
  var match = min_binding(t2);
  return bal(t1, match[0], match[1], remove_min_binding(t2));
}

function remove(x, m) {
  if (!m) {
    return /* Empty */0;
  }
  var r = m.r;
  var d = m.d;
  var v = m.v;
  var l = m.l;
  var c = Caml.caml_string_compare(x, v);
  if (c === 0) {
    return merge(l, r);
  }
  if (c < 0) {
    var ll = remove(x, l);
    if (l === ll) {
      return m;
    } else {
      return bal(ll, v, d, r);
    }
  }
  var rr = remove(x, r);
  if (r === rr) {
    return m;
  } else {
    return bal(l, v, d, rr);
  }
}

function update(x, f, m) {
  if (m) {
    var r = m.r;
    var d = m.d;
    var v = m.v;
    var l = m.l;
    var c = Caml.caml_string_compare(x, v);
    if (c === 0) {
      var data = Curry._1(f, Caml_option.some(d));
      if (data === undefined) {
        return merge(l, r);
      }
      var data$1 = Caml_option.valFromOption(data);
      if (d === data$1) {
        return m;
      } else {
        return /* Node */{
                l: l,
                v: x,
                d: data$1,
                r: r,
                h: m.h
              };
      }
    }
    if (c < 0) {
      var ll = update(x, f, l);
      if (l === ll) {
        return m;
      } else {
        return bal(ll, v, d, r);
      }
    }
    var rr = update(x, f, r);
    if (r === rr) {
      return m;
    } else {
      return bal(l, v, d, rr);
    }
  }
  var data$2 = Curry._1(f, undefined);
  if (data$2 !== undefined) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            d: Caml_option.valFromOption(data$2),
            r: /* Empty */0,
            h: 1
          };
  } else {
    return /* Empty */0;
  }
}

function iter(f, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    iter(f, param.l);
    Curry._2(f, param.v, param.d);
    _param = param.r;
    continue ;
  };
}

function map(f, param) {
  if (!param) {
    return /* Empty */0;
  }
  var l$p = map(f, param.l);
  var d$p = Curry._1(f, param.d);
  var r$p = map(f, param.r);
  return /* Node */{
          l: l$p,
          v: param.v,
          d: d$p,
          r: r$p,
          h: param.h
        };
}

function mapi(f, param) {
  if (!param) {
    return /* Empty */0;
  }
  var v = param.v;
  var l$p = mapi(f, param.l);
  var d$p = Curry._2(f, v, param.d);
  var r$p = mapi(f, param.r);
  return /* Node */{
          l: l$p,
          v: v,
          d: d$p,
          r: r$p,
          h: param.h
        };
}

function fold(f, _m, _accu) {
  while(true) {
    var accu = _accu;
    var m = _m;
    if (!m) {
      return accu;
    }
    _accu = Curry._3(f, m.v, m.d, fold(f, m.l, accu));
    _m = m.r;
    continue ;
  };
}

function for_all(p, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return true;
    }
    if (!Curry._2(p, param.v, param.d)) {
      return false;
    }
    if (!for_all(p, param.l)) {
      return false;
    }
    _param = param.r;
    continue ;
  };
}

function exists(p, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    if (Curry._2(p, param.v, param.d)) {
      return true;
    }
    if (exists(p, param.l)) {
      return true;
    }
    _param = param.r;
    continue ;
  };
}

function add_min_binding(k, x, param) {
  if (param) {
    return bal(add_min_binding(k, x, param.l), param.v, param.d, param.r);
  } else {
    return singleton(k, x);
  }
}

function add_max_binding(k, x, param) {
  if (param) {
    return bal(param.l, param.v, param.d, add_max_binding(k, x, param.r));
  } else {
    return singleton(k, x);
  }
}

function join(l, v, d, r) {
  if (!l) {
    return add_min_binding(v, d, r);
  }
  if (!r) {
    return add_max_binding(v, d, l);
  }
  var rh = r.h;
  var lh = l.h;
  if (lh > (rh + 2 | 0)) {
    return bal(l.l, l.v, l.d, join(l.r, v, d, r));
  } else if (rh > (lh + 2 | 0)) {
    return bal(join(l, v, d, r.l), r.v, r.d, r.r);
  } else {
    return create(l, v, d, r);
  }
}

function concat(t1, t2) {
  if (!t1) {
    return t2;
  }
  if (!t2) {
    return t1;
  }
  var match = min_binding(t2);
  return join(t1, match[0], match[1], remove_min_binding(t2));
}

function concat_or_join(t1, v, d, t2) {
  if (d !== undefined) {
    return join(t1, v, Caml_option.valFromOption(d), t2);
  } else {
    return concat(t1, t2);
  }
}

function split(x, param) {
  if (!param) {
    return [
            /* Empty */0,
            undefined,
            /* Empty */0
          ];
  }
  var r = param.r;
  var d = param.d;
  var v = param.v;
  var l = param.l;
  var c = Caml.caml_string_compare(x, v);
  if (c === 0) {
    return [
            l,
            Caml_option.some(d),
            r
          ];
  }
  if (c < 0) {
    var match = split(x, l);
    return [
            match[0],
            match[1],
            join(match[2], v, d, r)
          ];
  }
  var match$1 = split(x, r);
  return [
          join(l, v, d, match$1[0]),
          match$1[1],
          match$1[2]
        ];
}

function merge$1(f, s1, s2) {
  if (s1) {
    var v1 = s1.v;
    if (s1.h >= height(s2)) {
      var match = split(v1, s2);
      return concat_or_join(merge$1(f, s1.l, match[0]), v1, Curry._3(f, v1, Caml_option.some(s1.d), match[1]), merge$1(f, s1.r, match[2]));
    }
    
  } else if (!s2) {
    return /* Empty */0;
  }
  if (s2) {
    var v2 = s2.v;
    var match$1 = split(v2, s1);
    return concat_or_join(merge$1(f, match$1[0], s2.l), v2, Curry._3(f, v2, match$1[1], Caml_option.some(s2.d)), merge$1(f, match$1[2], s2.r));
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "map.ml",
          393,
          10
        ],
        Error: new Error()
      };
}

function union(f, s1, s2) {
  if (!s1) {
    return s2;
  }
  if (!s2) {
    return s1;
  }
  var d2 = s2.d;
  var v2 = s2.v;
  var d1 = s1.d;
  var v1 = s1.v;
  if (s1.h >= s2.h) {
    var match = split(v1, s2);
    var d2$1 = match[1];
    var l = union(f, s1.l, match[0]);
    var r = union(f, s1.r, match[2]);
    if (d2$1 !== undefined) {
      return concat_or_join(l, v1, Curry._3(f, v1, d1, Caml_option.valFromOption(d2$1)), r);
    } else {
      return join(l, v1, d1, r);
    }
  }
  var match$1 = split(v2, s1);
  var d1$1 = match$1[1];
  var l$1 = union(f, match$1[0], s2.l);
  var r$1 = union(f, match$1[2], s2.r);
  if (d1$1 !== undefined) {
    return concat_or_join(l$1, v2, Curry._3(f, v2, Caml_option.valFromOption(d1$1), d2), r$1);
  } else {
    return join(l$1, v2, d2, r$1);
  }
}

function filter(p, m) {
  if (!m) {
    return /* Empty */0;
  }
  var r = m.r;
  var d = m.d;
  var v = m.v;
  var l = m.l;
  var l$p = filter(p, l);
  var pvd = Curry._2(p, v, d);
  var r$p = filter(p, r);
  if (pvd) {
    if (l === l$p && r === r$p) {
      return m;
    } else {
      return join(l$p, v, d, r$p);
    }
  } else {
    return concat(l$p, r$p);
  }
}

function partition(p, param) {
  if (!param) {
    return [
            /* Empty */0,
            /* Empty */0
          ];
  }
  var d = param.d;
  var v = param.v;
  var match = partition(p, param.l);
  var lf = match[1];
  var lt = match[0];
  var pvd = Curry._2(p, v, d);
  var match$1 = partition(p, param.r);
  var rf = match$1[1];
  var rt = match$1[0];
  if (pvd) {
    return [
            join(lt, v, d, rt),
            concat(lf, rf)
          ];
  } else {
    return [
            concat(lt, rt),
            join(lf, v, d, rf)
          ];
  }
}

function cons_enum(_m, _e) {
  while(true) {
    var e = _e;
    var m = _m;
    if (!m) {
      return e;
    }
    _e = /* More */{
      _0: m.v,
      _1: m.d,
      _2: m.r,
      _3: e
    };
    _m = m.l;
    continue ;
  };
}

function compare(cmp, m1, m2) {
  var _e1 = cons_enum(m1, /* End */0);
  var _e2 = cons_enum(m2, /* End */0);
  while(true) {
    var e2 = _e2;
    var e1 = _e1;
    if (!e1) {
      if (e2) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!e2) {
      return 1;
    }
    var c = Caml.caml_string_compare(e1._0, e2._0);
    if (c !== 0) {
      return c;
    }
    var c$1 = Curry._2(cmp, e1._1, e2._1);
    if (c$1 !== 0) {
      return c$1;
    }
    _e2 = cons_enum(e2._2, e2._3);
    _e1 = cons_enum(e1._2, e1._3);
    continue ;
  };
}

function equal(cmp, m1, m2) {
  var _e1 = cons_enum(m1, /* End */0);
  var _e2 = cons_enum(m2, /* End */0);
  while(true) {
    var e2 = _e2;
    var e1 = _e1;
    if (!e1) {
      if (e2) {
        return false;
      } else {
        return true;
      }
    }
    if (!e2) {
      return false;
    }
    if (Caml.caml_string_compare(e1._0, e2._0) !== 0) {
      return false;
    }
    if (!Curry._2(cmp, e1._1, e2._1)) {
      return false;
    }
    _e2 = cons_enum(e2._2, e2._3);
    _e1 = cons_enum(e1._2, e1._3);
    continue ;
  };
}

function cardinal(param) {
  if (param) {
    return (cardinal(param.l) + 1 | 0) + cardinal(param.r) | 0;
  } else {
    return 0;
  }
}

function bindings_aux(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (!param) {
      return accu;
    }
    _param = param.l;
    _accu = {
      hd: [
        param.v,
        param.d
      ],
      tl: bindings_aux(accu, param.r)
    };
    continue ;
  };
}

function bindings(s) {
  return bindings_aux(/* [] */0, s);
}

var ObjectDict = {
  empty: /* Empty */0,
  is_empty: is_empty,
  mem: mem,
  add: add,
  update: update,
  singleton: singleton,
  remove: remove,
  merge: merge$1,
  union: union,
  compare: compare,
  equal: equal,
  iter: iter,
  fold: fold,
  for_all: for_all,
  exists: exists,
  filter: filter,
  partition: partition,
  cardinal: cardinal,
  bindings: bindings,
  min_binding: min_binding,
  min_binding_opt: min_binding_opt,
  max_binding: max_binding,
  max_binding_opt: max_binding_opt,
  choose: min_binding,
  choose_opt: min_binding_opt,
  split: split,
  find: find,
  find_opt: find_opt,
  find_first: find_first,
  find_first_opt: find_first_opt,
  find_last: find_last,
  find_last_opt: find_last_opt,
  map: map,
  mapi: mapi
};

var ParseFail = /* @__PURE__ */Caml_exceptions.create("Tea_json.Decoder.ParseFail");

var string = /* Decoder */{
  _0: (function (value) {
      var s = Web_json.classify(value);
      if (typeof s === "number" || s.TAG !== /* JSONString */0) {
        return {
                TAG: /* Error */1,
                _0: "Non-string value"
              };
      } else {
        return {
                TAG: /* Ok */0,
                _0: s._0
              };
      }
    })
};

var $$int = /* Decoder */{
  _0: (function (value) {
      var n = Web_json.classify(value);
      if (typeof n === "number") {
        return {
                TAG: /* Error */1,
                _0: "Non-int value"
              };
      }
      if (n.TAG !== /* JSONNumber */1) {
        return {
                TAG: /* Error */1,
                _0: "Non-int value"
              };
      }
      var n$1 = n._0;
      if (n$1 > Pervasives.min_int && n$1 < Pervasives.max_int) {
        return {
                TAG: /* Ok */0,
                _0: n$1 | 0
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: "number out of int range"
              };
      }
    })
};

var $$float = /* Decoder */{
  _0: (function (value) {
      var n = Web_json.classify(value);
      if (typeof n === "number" || n.TAG !== /* JSONNumber */1) {
        return {
                TAG: /* Error */1,
                _0: "Non-float-value"
              };
      } else {
        return {
                TAG: /* Ok */0,
                _0: n._0
              };
      }
    })
};

var bool = /* Decoder */{
  _0: (function (value) {
      var match = Web_json.classify(value);
      if (typeof match !== "number") {
        return {
                TAG: /* Error */1,
                _0: "Non-boolean value"
              };
      }
      switch (match) {
        case /* JSONFalse */0 :
            return {
                    TAG: /* Ok */0,
                    _0: false
                  };
        case /* JSONTrue */1 :
            return {
                    TAG: /* Ok */0,
                    _0: true
                  };
        case /* JSONNull */2 :
            return {
                    TAG: /* Error */1,
                    _0: "Non-boolean value"
                  };
        
      }
    })
};

function $$null(v) {
  return /* Decoder */{
          _0: (function (value) {
              var match = Web_json.classify(value);
              if (typeof match === "number" && match >= 2) {
                return {
                        TAG: /* Ok */0,
                        _0: v
                      };
              } else {
                return {
                        TAG: /* Error */1,
                        _0: "Non-null value"
                      };
              }
            })
        };
}

function list(decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var a = Web_json.classify(value);
              if (typeof a === "number") {
                return {
                        TAG: /* Error */1,
                        _0: "Non-list value"
                      };
              }
              if (a.TAG !== /* JSONArray */3) {
                return {
                        TAG: /* Error */1,
                        _0: "Non-list value"
                      };
              }
              var parse = function (v) {
                var r = Curry._1(decoder$1, v);
                if (r.TAG === /* Ok */0) {
                  return r._0;
                }
                throw {
                      RE_EXN_ID: ParseFail,
                      _1: r._0,
                      Error: new Error()
                    };
              };
              try {
                return {
                        TAG: /* Ok */0,
                        _0: List.map(parse, $$Array.to_list(a._0))
                      };
              }
              catch (raw_e){
                var e = Caml_js_exceptions.internalToOCamlException(raw_e);
                if (e.RE_EXN_ID === ParseFail) {
                  return {
                          TAG: /* Error */1,
                          _0: "list -> " + e._1
                        };
                }
                throw e;
              }
            })
        };
}

function array(decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var a = Web_json.classify(value);
              if (typeof a === "number") {
                return {
                        TAG: /* Error */1,
                        _0: "Non-array value"
                      };
              }
              if (a.TAG !== /* JSONArray */3) {
                return {
                        TAG: /* Error */1,
                        _0: "Non-array value"
                      };
              }
              var parse = function (v) {
                var r = Curry._1(decoder$1, v);
                if (r.TAG === /* Ok */0) {
                  return r._0;
                }
                throw {
                      RE_EXN_ID: ParseFail,
                      _1: r._0,
                      Error: new Error()
                    };
              };
              try {
                return {
                        TAG: /* Ok */0,
                        _0: $$Array.map(parse, a._0)
                      };
              }
              catch (raw_e){
                var e = Caml_js_exceptions.internalToOCamlException(raw_e);
                if (e.RE_EXN_ID === ParseFail) {
                  return {
                          TAG: /* Error */1,
                          _0: "array -> " + e._1
                        };
                }
                throw e;
              }
            })
        };
}

function keyValuePairs(decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var o = Web_json.classify(value);
              if (typeof o === "number") {
                return {
                        TAG: /* Error */1,
                        _0: "Non-keyValuePair value"
                      };
              }
              if (o.TAG !== /* JSONObject */2) {
                return {
                        TAG: /* Error */1,
                        _0: "Non-keyValuePair value"
                      };
              }
              var o$1 = o._0;
              var keys = Object.keys(o$1);
              var parse = function (k, l) {
                var v = Js_dict.get(o$1, k);
                if (v !== undefined) {
                  var r = Curry._1(decoder$1, Caml_option.valFromOption(v));
                  if (r.TAG === /* Ok */0) {
                    return {
                            hd: [
                              k,
                              r._0
                            ],
                            tl: l
                          };
                  }
                  throw {
                        RE_EXN_ID: ParseFail,
                        _1: r._0,
                        Error: new Error()
                      };
                }
                throw {
                      RE_EXN_ID: ParseFail,
                      _1: "Key is undefined: " + k,
                      Error: new Error()
                    };
              };
              try {
                return {
                        TAG: /* Ok */0,
                        _0: $$Array.fold_right(parse, keys, /* [] */0)
                      };
              }
              catch (raw_e){
                var e = Caml_js_exceptions.internalToOCamlException(raw_e);
                if (e.RE_EXN_ID === ParseFail) {
                  return {
                          TAG: /* Error */1,
                          _0: "Invalid keyValuePair parsing: " + e._1
                        };
                }
                throw e;
              }
            })
        };
}

function dict(decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var o = Web_json.classify(value);
              if (typeof o === "number") {
                return {
                        TAG: /* Error */1,
                        _0: "Non-dict value"
                      };
              }
              if (o.TAG !== /* JSONObject */2) {
                return {
                        TAG: /* Error */1,
                        _0: "Non-dict value"
                      };
              }
              var o$1 = o._0;
              var keys = Object.keys(o$1);
              var parse = function (k, d) {
                var v = Js_dict.get(o$1, k);
                if (v !== undefined) {
                  var r = Curry._1(decoder$1, Caml_option.valFromOption(v));
                  if (r.TAG === /* Ok */0) {
                    return add(k, r._0, d);
                  }
                  throw {
                        RE_EXN_ID: ParseFail,
                        _1: r._0,
                        Error: new Error()
                      };
                }
                throw {
                      RE_EXN_ID: ParseFail,
                      _1: "Key is undefined: " + k,
                      Error: new Error()
                    };
              };
              try {
                return {
                        TAG: /* Ok */0,
                        _0: $$Array.fold_right(parse, keys, /* Empty */0)
                      };
              }
              catch (raw_e){
                var e = Caml_js_exceptions.internalToOCamlException(raw_e);
                if (e.RE_EXN_ID === ParseFail) {
                  return {
                          TAG: /* Error */1,
                          _0: "Invalid dict parsing: " + e._1
                        };
                }
                throw e;
              }
            })
        };
}

function field(key, decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var o = Web_json.classify(value);
              if (typeof o === "number") {
                return {
                        TAG: /* Error */1,
                        _0: "Non-fieldable value"
                      };
              }
              if (o.TAG !== /* JSONObject */2) {
                return {
                        TAG: /* Error */1,
                        _0: "Non-fieldable value"
                      };
              }
              var v = Js_dict.get(o._0, key);
              if (v === undefined) {
                return {
                        TAG: /* Error */1,
                        _0: "Field Value is undefined: " + key
                      };
              }
              var o$1 = Curry._1(decoder$1, Caml_option.valFromOption(v));
              if (o$1.TAG === /* Ok */0) {
                return o$1;
              } else {
                return {
                        TAG: /* Error */1,
                        _0: "field `" + (key + ("` -> " + o$1._0))
                      };
              }
            })
        };
}

function at(fields, dec) {
  return List.fold_right(field, fields, dec);
}

function index(idx, decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var a = Web_json.classify(value);
              if (typeof a === "number") {
                return {
                        TAG: /* Error */1,
                        _0: "Non-array value"
                      };
              }
              if (a.TAG !== /* JSONArray */3) {
                return {
                        TAG: /* Error */1,
                        _0: "Non-array value"
                      };
              }
              var a$1 = a._0;
              if (idx < 0 || idx > a$1.length) {
                return {
                        TAG: /* Error */1,
                        _0: "Array index out of range: " + String(idx)
                      };
              } else {
                return Curry._1(decoder$1, Caml_array.get(a$1, idx));
              }
            })
        };
}

function maybe(decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var r = Curry._1(decoder$1, value);
              if (r.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Caml_option.some(r._0)
                      };
              } else {
                return {
                        TAG: /* Ok */0,
                        _0: undefined
                      };
              }
            })
        };
}

function oneOf(decoders) {
  return /* Decoder */{
          _0: (function (value) {
              var parse = function (v, _x) {
                while(true) {
                  var x = _x;
                  if (!x) {
                    return {
                            TAG: /* Error */1,
                            _0: "No one-of's matched"
                          };
                  }
                  var rest = x.tl;
                  try {
                    var ok = Curry._1(x.hd._0, v);
                    if (ok.TAG === /* Ok */0) {
                      return ok;
                    } else {
                      return parse(v, rest);
                    }
                  }
                  catch (exn){
                    _x = rest;
                    continue ;
                  }
                };
              };
              return parse(value, decoders);
            })
        };
}

function map$1(mapper, decoder1) {
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var v1 = Curry._1(decoder1$1, value);
              if (v1.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._1(mapper, v1._0)
                      };
              } else {
                return {
                        TAG: /* Error */1,
                        _0: "map " + v1._0
                      };
              }
            })
        };
}

function map2(mapper, decoder1, decoder2) {
  var decoder2$1 = decoder2._0;
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var match = Curry._1(decoder1$1, value);
              var match$1 = Curry._1(decoder2$1, value);
              if (match.TAG === /* Ok */0 && match$1.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._2(mapper, match._0, match$1._0)
                      };
              }
              var e = Tea_result.error_of_first(match, match$1);
              if (e !== undefined) {
                return {
                        TAG: /* Error */1,
                        _0: "map2 -> " + e
                      };
              }
              throw {
                    RE_EXN_ID: "Failure",
                    _1: "Impossible case",
                    Error: new Error()
                  };
            })
        };
}

function map3(mapper, decoder1, decoder2, decoder3) {
  var decoder3$1 = decoder3._0;
  var decoder2$1 = decoder2._0;
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var match = Curry._1(decoder1$1, value);
              var match$1 = Curry._1(decoder2$1, value);
              var match$2 = Curry._1(decoder3$1, value);
              if (match.TAG === /* Ok */0 && match$1.TAG === /* Ok */0 && match$2.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._3(mapper, match._0, match$1._0, match$2._0)
                      };
              }
              var e = Tea_result.first(match$2, Tea_result.first(match$1, match));
              if (e.TAG !== /* Ok */0) {
                return {
                        TAG: /* Error */1,
                        _0: "map3 -> " + e._0
                      };
              }
              throw {
                    RE_EXN_ID: "Failure",
                    _1: "Impossible case",
                    Error: new Error()
                  };
            })
        };
}

function map4(mapper, decoder1, decoder2, decoder3, decoder4) {
  var decoder4$1 = decoder4._0;
  var decoder3$1 = decoder3._0;
  var decoder2$1 = decoder2._0;
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var match = Curry._1(decoder1$1, value);
              var match$1 = Curry._1(decoder2$1, value);
              var match$2 = Curry._1(decoder3$1, value);
              var match$3 = Curry._1(decoder4$1, value);
              if (match.TAG === /* Ok */0 && match$1.TAG === /* Ok */0 && match$2.TAG === /* Ok */0 && match$3.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._4(mapper, match._0, match$1._0, match$2._0, match$3._0)
                      };
              }
              var e = Tea_result.first(match$3, Tea_result.first(match$2, Tea_result.first(match$1, match)));
              if (e.TAG !== /* Ok */0) {
                return {
                        TAG: /* Error */1,
                        _0: "map4 -> " + e._0
                      };
              }
              throw {
                    RE_EXN_ID: "Failure",
                    _1: "Impossible case",
                    Error: new Error()
                  };
            })
        };
}

function map5(mapper, decoder1, decoder2, decoder3, decoder4, decoder5) {
  var decoder5$1 = decoder5._0;
  var decoder4$1 = decoder4._0;
  var decoder3$1 = decoder3._0;
  var decoder2$1 = decoder2._0;
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var match = Curry._1(decoder1$1, value);
              var match$1 = Curry._1(decoder2$1, value);
              var match$2 = Curry._1(decoder3$1, value);
              var match$3 = Curry._1(decoder4$1, value);
              var match$4 = Curry._1(decoder5$1, value);
              if (match.TAG === /* Ok */0 && match$1.TAG === /* Ok */0 && match$2.TAG === /* Ok */0 && match$3.TAG === /* Ok */0 && match$4.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._5(mapper, match._0, match$1._0, match$2._0, match$3._0, match$4._0)
                      };
              }
              var e = Tea_result.first(match$4, Tea_result.first(match$3, Tea_result.first(match$2, Tea_result.first(match$1, match))));
              if (e.TAG !== /* Ok */0) {
                return {
                        TAG: /* Error */1,
                        _0: "map5 -> " + e._0
                      };
              }
              throw {
                    RE_EXN_ID: "Failure",
                    _1: "Impossible case",
                    Error: new Error()
                  };
            })
        };
}

function map6(mapper, decoder1, decoder2, decoder3, decoder4, decoder5, decoder6) {
  var decoder6$1 = decoder6._0;
  var decoder5$1 = decoder5._0;
  var decoder4$1 = decoder4._0;
  var decoder3$1 = decoder3._0;
  var decoder2$1 = decoder2._0;
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var match = Curry._1(decoder1$1, value);
              var match$1 = Curry._1(decoder2$1, value);
              var match$2 = Curry._1(decoder3$1, value);
              var match$3 = Curry._1(decoder4$1, value);
              var match$4 = Curry._1(decoder5$1, value);
              var match$5 = Curry._1(decoder6$1, value);
              if (match.TAG === /* Ok */0 && match$1.TAG === /* Ok */0 && match$2.TAG === /* Ok */0 && match$3.TAG === /* Ok */0 && match$4.TAG === /* Ok */0 && match$5.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._6(mapper, match._0, match$1._0, match$2._0, match$3._0, match$4._0, match$5._0)
                      };
              }
              var e = Tea_result.first(match$5, Tea_result.first(match$4, Tea_result.first(match$3, Tea_result.first(match$2, Tea_result.first(match$1, match)))));
              if (e.TAG !== /* Ok */0) {
                return {
                        TAG: /* Error */1,
                        _0: "map6 -> " + e._0
                      };
              }
              throw {
                    RE_EXN_ID: "Failure",
                    _1: "Impossible case",
                    Error: new Error()
                  };
            })
        };
}

function map7(mapper, decoder1, decoder2, decoder3, decoder4, decoder5, decoder6, decoder7) {
  var decoder7$1 = decoder7._0;
  var decoder6$1 = decoder6._0;
  var decoder5$1 = decoder5._0;
  var decoder4$1 = decoder4._0;
  var decoder3$1 = decoder3._0;
  var decoder2$1 = decoder2._0;
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var match = Curry._1(decoder1$1, value);
              var match$1 = Curry._1(decoder2$1, value);
              var match$2 = Curry._1(decoder3$1, value);
              var match$3 = Curry._1(decoder4$1, value);
              var match$4 = Curry._1(decoder5$1, value);
              var match$5 = Curry._1(decoder6$1, value);
              var match$6 = Curry._1(decoder7$1, value);
              if (match.TAG === /* Ok */0 && match$1.TAG === /* Ok */0 && match$2.TAG === /* Ok */0 && match$3.TAG === /* Ok */0 && match$4.TAG === /* Ok */0 && match$5.TAG === /* Ok */0 && match$6.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._7(mapper, match._0, match$1._0, match$2._0, match$3._0, match$4._0, match$5._0, match$6._0)
                      };
              }
              var e = Tea_result.first(match$6, Tea_result.first(match$5, Tea_result.first(match$4, Tea_result.first(match$3, Tea_result.first(match$2, Tea_result.first(match$1, match))))));
              if (e.TAG !== /* Ok */0) {
                return {
                        TAG: /* Error */1,
                        _0: "map7 -> " + e._0
                      };
              }
              throw {
                    RE_EXN_ID: "Failure",
                    _1: "Impossible case",
                    Error: new Error()
                  };
            })
        };
}

function map8(mapper, decoder1, decoder2, decoder3, decoder4, decoder5, decoder6, decoder7, decoder8) {
  var decoder8$1 = decoder8._0;
  var decoder7$1 = decoder7._0;
  var decoder6$1 = decoder6._0;
  var decoder5$1 = decoder5._0;
  var decoder4$1 = decoder4._0;
  var decoder3$1 = decoder3._0;
  var decoder2$1 = decoder2._0;
  var decoder1$1 = decoder1._0;
  return /* Decoder */{
          _0: (function (value) {
              var match = Curry._1(decoder1$1, value);
              var match$1 = Curry._1(decoder2$1, value);
              var match$2 = Curry._1(decoder3$1, value);
              var match$3 = Curry._1(decoder4$1, value);
              var match$4 = Curry._1(decoder5$1, value);
              var match$5 = Curry._1(decoder6$1, value);
              var match$6 = Curry._1(decoder7$1, value);
              var match$7 = Curry._1(decoder8$1, value);
              if (match.TAG === /* Ok */0 && match$1.TAG === /* Ok */0 && match$2.TAG === /* Ok */0 && match$3.TAG === /* Ok */0 && match$4.TAG === /* Ok */0 && match$5.TAG === /* Ok */0 && match$6.TAG === /* Ok */0 && match$7.TAG === /* Ok */0) {
                return {
                        TAG: /* Ok */0,
                        _0: Curry._8(mapper, match._0, match$1._0, match$2._0, match$3._0, match$4._0, match$5._0, match$6._0, match$7._0)
                      };
              }
              var e = Tea_result.first(match$7, Tea_result.first(match$6, Tea_result.first(match$5, Tea_result.first(match$4, Tea_result.first(match$3, Tea_result.first(match$2, Tea_result.first(match$1, match)))))));
              if (e.TAG !== /* Ok */0) {
                return {
                        TAG: /* Error */1,
                        _0: "map8 -> " + e._0
                      };
              }
              throw {
                    RE_EXN_ID: "Failure",
                    _1: "Impossible case",
                    Error: new Error()
                  };
            })
        };
}

function succeed(v) {
  return /* Decoder */{
          _0: (function (_value) {
              return {
                      TAG: /* Ok */0,
                      _0: v
                    };
            })
        };
}

function fail(e) {
  return /* Decoder */{
          _0: (function (_value) {
              return {
                      TAG: /* Error */1,
                      _0: e
                    };
            })
        };
}

var value = /* Decoder */{
  _0: (function (value) {
      return {
              TAG: /* Ok */0,
              _0: value
            };
    })
};

function andThen(func, decoder) {
  var decoder$1 = decoder._0;
  return /* Decoder */{
          _0: (function (value) {
              var r = Curry._1(decoder$1, value);
              if (r.TAG !== /* Ok */0) {
                return r;
              }
              var andThenDecoder = Curry._1(func, r._0);
              return Curry._1(andThenDecoder._0, value);
            })
        };
}

function lazy_(func) {
  return andThen(func, /* Decoder */{
              _0: (function (_value) {
                  return {
                          TAG: /* Ok */0,
                          _0: undefined
                        };
                })
            });
}

function nullable(decoder) {
  return oneOf({
              hd: $$null(undefined),
              tl: {
                hd: map$1((function (v) {
                        return Caml_option.some(v);
                      }), decoder),
                tl: /* [] */0
              }
            });
}

function decodeValue(decoder, value) {
  try {
    return Curry._1(decoder._0, value);
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    if (e.RE_EXN_ID === ParseFail) {
      return {
              TAG: /* Error */1,
              _0: e._1
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: "Unknown JSON parsing error"
            };
    }
  }
}

function decodeEvent(decoder, value) {
  try {
    return Curry._1(decoder._0, value);
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    if (e.RE_EXN_ID === ParseFail) {
      return {
              TAG: /* Error */1,
              _0: e._1
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: "Unknown JSON parsing error"
            };
    }
  }
}

function decodeString(decoder, string) {
  try {
    var value = JSON.parse(string);
    return decodeValue(decoder, value);
  }
  catch (exn){
    return {
            TAG: /* Error */1,
            _0: "Invalid JSON string"
          };
  }
}

var Decoder = {
  ObjectDict: ObjectDict,
  ParseFail: ParseFail,
  string: string,
  $$int: $$int,
  $$float: $$float,
  bool: bool,
  $$null: $$null,
  list: list,
  array: array,
  keyValuePairs: keyValuePairs,
  dict: dict,
  field: field,
  at: at,
  index: index,
  maybe: maybe,
  oneOf: oneOf,
  map: map$1,
  map2: map2,
  map3: map3,
  map4: map4,
  map5: map5,
  map6: map6,
  map7: map7,
  map8: map8,
  succeed: succeed,
  fail: fail,
  value: value,
  andThen: andThen,
  lazy_: lazy_,
  nullable: nullable,
  decodeValue: decodeValue,
  decodeEvent: decodeEvent,
  decodeString: decodeString
};

function encode(indentLevel, value) {
  return Web_json.string_of_json(indentLevel, value);
}

function string$1(v) {
  return v;
}

function $$int$1(v) {
  return v;
}

function $$float$1(v) {
  return v;
}

function bool$1(v) {
  return v;
}

function object_(v) {
  var aux = function (o, param) {
    o[param[0]] = param[1];
    return o;
  };
  return List.fold_left(aux, {}, v);
}

function array$1(v) {
  return v;
}

var list$1 = $$Array.of_list;

var Encoder_null = null;

var Encoder = {
  encode: encode,
  string: string$1,
  $$int: $$int$1,
  $$float: $$float$1,
  bool: bool$1,
  $$null: Encoder_null,
  object_: object_,
  array: array$1,
  list: list$1
};

exports.Decoder = Decoder;
exports.Encoder = Encoder;
/* No side effect */
