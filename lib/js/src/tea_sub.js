// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("rescript/lib/js/list.js");
var Vdom = require("./vdom.js");
var Curry = require("rescript/lib/js/curry.js");

function batch(subs) {
  return {
          TAG: /* Batch */0,
          _0: subs
        };
}

function registration(key, enableCall) {
  return {
          TAG: /* Registration */1,
          _0: key,
          _1: (function (callbacks) {
              return Curry._1(enableCall, callbacks.contents);
            }),
          _2: {
            contents: undefined
          }
        };
}

function map(msgMapper, sub) {
  var func = function (callbacks) {
    return Vdom.wrapCallbacks(msgMapper, callbacks);
  };
  return {
          TAG: /* Mapper */2,
          _0: func,
          _1: sub
        };
}

function mapFunc(func, sub) {
  return {
          TAG: /* Mapper */2,
          _0: func,
          _1: sub
        };
}

function run(oldCallbacks, newCallbacks, oldSub, newSub) {
  var enable = function (_callbacks, _x) {
    while(true) {
      var x = _x;
      var callbacks = _callbacks;
      if (typeof x === "number") {
        return ;
      }
      switch (x.TAG | 0) {
        case /* Batch */0 :
            var subs = x._0;
            if (subs) {
              return List.iter((function(callbacks){
                        return function (param) {
                          return enable(callbacks, param);
                        }
                        }(callbacks)), subs);
            } else {
              return ;
            }
        case /* Registration */1 :
            x._2.contents = Curry._1(x._1, callbacks);
            return ;
        case /* Mapper */2 :
            var subCallbacks = Curry._1(x._0, callbacks);
            _x = x._1;
            _callbacks = subCallbacks;
            continue ;
        
      }
    };
  };
  var disable = function (_callbacks, _x) {
    while(true) {
      var x = _x;
      var callbacks = _callbacks;
      if (typeof x === "number") {
        return ;
      }
      switch (x.TAG | 0) {
        case /* Batch */0 :
            var subs = x._0;
            if (subs) {
              return List.iter((function(callbacks){
                        return function (param) {
                          return disable(callbacks, param);
                        }
                        }(callbacks)), subs);
            } else {
              return ;
            }
        case /* Registration */1 :
            var diCB = x._2;
            var cb = diCB.contents;
            if (cb !== undefined) {
              diCB.contents = undefined;
              return Curry._1(cb, undefined);
            } else {
              return ;
            }
        case /* Mapper */2 :
            var subCallbacks = Curry._1(x._0, callbacks);
            _x = x._1;
            _callbacks = subCallbacks;
            continue ;
        
      }
    };
  };
  if (typeof oldSub === "number") {
    if (typeof newSub === "number") {
      return newSub;
    }
    
  } else {
    switch (oldSub.TAG | 0) {
      case /* Batch */0 :
          if (typeof newSub !== "number" && newSub.TAG === /* Batch */0) {
            var aux = function (_oldList, _newList) {
              while(true) {
                var newList = _newList;
                var oldList = _oldList;
                if (oldList) {
                  var oldRest = oldList.tl;
                  var oldSubSub = oldList.hd;
                  if (newList) {
                    run(oldCallbacks, newCallbacks, oldSubSub, newList.hd);
                    _newList = newList.tl;
                    _oldList = oldRest;
                    continue ;
                  }
                  disable(oldCallbacks, oldSubSub);
                  _newList = /* [] */0;
                  _oldList = oldRest;
                  continue ;
                }
                if (!newList) {
                  return ;
                }
                enable(newCallbacks, newList.hd);
                _newList = newList.tl;
                _oldList = /* [] */0;
                continue ;
              };
            };
            aux(oldSub._0, newSub._0);
            return newSub;
          }
          break;
      case /* Registration */1 :
          if (typeof newSub !== "number" && newSub.TAG === /* Registration */1 && oldSub._0 === newSub._0) {
            newSub._2.contents = oldSub._2.contents;
            return newSub;
          }
          break;
      case /* Mapper */2 :
          if (typeof newSub !== "number" && newSub.TAG === /* Mapper */2) {
            var olderCallbacks = Curry._1(oldSub._0, oldCallbacks);
            var newerCallbacks = Curry._1(newSub._0, newCallbacks);
            run(olderCallbacks, newerCallbacks, oldSub._1, newSub._1);
            return newSub;
          }
          break;
      
    }
  }
  disable(oldCallbacks, oldSub);
  enable(newCallbacks, newSub);
  return newSub;
}

var none = /* NoSub */0;

exports.none = none;
exports.batch = batch;
exports.registration = registration;
exports.map = map;
exports.mapFunc = mapFunc;
exports.run = run;
/* No side effect */
